На данный момент реализована самая сложная часть, которая по моим подсчётам должна была занять куда больше времени - построение `Control Flow Graph`. За это время я пытался решить эту задачу совершенно разными способами, начиная от собственного AST парсера, заканчивая плагинами и скриптами для гидры. 
Как раз-таки собственный скрипт для гидры решил всю задачу в полной мере.

Уже полученный скрипт самодостаточно может помочь в решение задач обратной разработки, позволяя без особого труда разбирать ПО по ветвям в порядке исполнения функций (а точнее их вызова иерархично начиная с entry_point-ов). Скрипт написан на языке Java и на данный момент работает под Ghidra версией 11.3 (в целом адаптировать под актуальные версии не составит никакого труда). В результате выполнения создаются `.json` и `.dot` файлы. Последний файл можно с помощью одноимённой утилиты визуализировать в `.png`, пример которого представляю вам ниже.

Скрипт протестирован на нескольких небольших программах, в перспективе (что происходит в данный момент) протестировать его на прошивках. 
В целом `.json` и `.dot` файлы графа для прошивки есть у меня уже, то есть скрипт отработал, но получить `.png` пока не получилось, ибо сам граф уж очень большой, а программа `dot` писалась ещё в 90-ых и не рассчитана на многопоточность, а значит никак не оптимизирована (на очень мощном ПК (32 ядра, 256 ГБ оперативки, 16 Гб Видеопамяти) работает уже почти сутки). 

В ближайшее время нужно тестировать скрипт и после того, как получится убедится в его абсолютной работоспособности, преступить к реализации предпоследней стадии перед демонстрацией демо-версии - написать менеджер-утилиту для взаимодействия LLM с полученным графом. Данная программа как раз и должна реализовывать всю логику нашей задумки, обходя всю программу по графу, выполняя сканирование на предмет уязвимостей с учётом контекста исполнения.

Как-то так.