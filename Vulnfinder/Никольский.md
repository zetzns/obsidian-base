1) забрать все типы и сделать forward-declaration для кого положено 
2) генерировать все типы и их тоже надо отсортировать по зависимостям
3) сгенерировать прототипы функций
поискать готовый код который уже есть в гидре ибо он же сам как-то генерирует хэдеры.

Java генерирует xml для типов которые нужны они по pipe передаются в C-имплементацию декомпилятора и он дальше выполняет команды которые нужны, само общение идёт по пайпу. Соответсвенно мы можем докостылить в том же декомпиляторе чтобы он делал то, что нам нужно.

"Я по-моему добавлял команду в C-декомпилятор, которая делала всё, что мне надо, а экспорт у меня был в xml. Ты можешь упростить и просто все типы которые тебя не хватают кинуть в C-код. Либо найти в декомпиляторе тот блок, который генерирует типы и вызвать его через отдельную программу".

"Если кратко, то посмотри как он принимает сам решение, какой тип генерировать, какой нет. Решение он принимает скорее всего в C-шной части гидры в декомпиляторе. Общение с ним происходит по пайпу с помощью XML структур. 2ая мысль заключается в том, что нужно понять, почему он не генерирует какие-то типы, может там не стоит какой-нибудь флажок, какой-нибудь тип помечен invisible. Можно начать с того, чтобы твой плагин попросить руками сгенерировать только какую-нибудь одну функцию с каким-нибудь зависимым типом, который вот генерирует ошибку, чтобы была не стена ошибок, а вот какая-нибудь одна, чтобы на её примере пофиксить всё. Вот и смотри этот блок, что там работает, что там не работает. Я там этот компилятор в visual studio в целом запускал в отладчике и смотрел, как он там работает. По-моему да, вся генерация происходит в C-коде, но ты писал плагин - тебе виднее. Если это так, то тебе надо разобраться, почему принимается решение не генерировать этот тип, причины на это может быть две: 1 -  тип помечен каким-то битом, флагом или опцией, что его не надо генерировать; 2 - для генерации не хватает зависимости, например не хватает какого-то typedef"