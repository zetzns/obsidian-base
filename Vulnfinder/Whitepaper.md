# Vulnerability scanner LLM based


> [!problem] 
> Анализ кода ***большого размера*** (порядка нескольких миллионов строк) может занимать недели, месяцы, так как порой для получения **стабильного эксплоита** требуется понимание всего контекста исполнения.
> 

> [!finally]
> Данный проект может стать решением данной проблемы. Автоматизация поиска уязвимости с помощью большой языковой модели позволит находить уязвимые участки кода, которые имеют потенциал к эксплуатации.

# Наиболее упрощённый вид проекта

![[Pasted image 20250710123005.png]]
# Проблемы

> [!problem] Problem 1 
> Ни одна из существующих `LLM` ***не обладает контекстным окном, способным принять даже 1 млн строчек***. При этом разбивать код на части (впрямую, без разбора) не даст желаемого результата, ведь **модель не сможет хранить контекст предыдущего ответа** (в полном размере), а значит будет терять в понимании контекста выполнения кода, что неминуемо приведёт к галлюцинациям языковой модели и потерям в качестве результата (некоторые уязвимости найдены не будут, а некоторые найденные не будут пригодны к эксплуатации).
> 

> [!problem] Problem 2
> Имеющиеся языковые модели `недостаточно обучены` на предмет нахождения уязвимостей - для этого необходимо дообучать модель.

> [!problem] Problem 3
> Для работы с крупной и мощной языковой моделью необходимо сильное `железо`.

# Решение проблем

> [!solved] Problem 1
> Решением данной проблемы является `преобразование кода в граф` по принципу вызовов. Более того, мы не будем терять в контексте, сохраняя важную информацию о передаваемых в функции далее аргументах, а также о всех уязвимостях, найденных на данном этапе. Также необходимо предусмотреть обратную передачу всего найденного контекста (и его преобразование в минимальный вид, для минимизации дополнительного контекста) в исходную вызываемую функцию, в случае образования цикла в графе (например, в функции *main* была вызвана *a = foo()*, после выполнения *foo* RIP вернётся обратно на *main*, а значит, нам, возможно, понадобится информации об уязвимых участках внутри *foo* и всех его возможных *child-вызовах* и так далее). Проход по графу по одной функции будет решать эту проблему, ведь нам будет необходимо ***загружать в модель лишь функции в порядке их вызова по ветвям исполнения***. Покрыв весь код, нам будет известно, как добраться до уязвимых кусков кода и что можно с этим сделать.
> 
> Таким образом, наш инструмент будет из исходного кода создавать граф кода и отправлять в порядке вызовов код внутрь языковой модели.
> 

> [!solved] Problem 2
> Обучение модели строится по принципу образования условного `JSON`-файла в формате 
> {input: <'code'>; output:<предполагаемый вывод модели>}
> Где нам предстоит образовать `code`-базу из уязвимых и безопасных вызовов различных функций в роде **printf, gets...**, а `output` из желаемого ответа модели на каждый соответствующий кусок кода (сам уязвимый кусок код + универсальные советы по эксплуатации (можно написать на каждую CWE)).
> 
> Очень удобно, что в интернете уже можно найти целые базы данных с примерами уязвимых вызовов, а значит, всё, что останется - создание множества (порядка 5000 на каждую CWE) примеров безопасного использования этих функций, выбор (порядка 5000 на каждую CWE) уязвимых вариантов среди имеющихся данных, а также генерация желаемого `пояснения модели`.

> [!solved] Problem 3
> 32 Гб Видеопамяти
> 128 Гб ОЗУ

# Итоговый вид проекта

![[Pasted image 20250710124054.png]]

# Преобразование исходного кода в граф

## Псевдокод 

```scss
procedure BUILD_CODE_GRAPH(source_paths : list<Path>, out_path : Path)
    TIMER_START(T_total)

    // ── 1. Чтение входных файлов ─────────────────────────────────────────
    files_buf ← PARALLEL_MAP(source_paths, LOAD_MMAP)

    // ── 2. Препроцессинг (include-ы, макросы, условная компиляция) ───────
    tu ← PREPROCESS(files_buf)                         // Translation Unit

    // ── 3. Лексический анализ ────────────────────────────────────────────
    tokens ← LEX(tu)

    // ── 4. Синтаксический анализ → AST ───────────────────────────────────
    ast ← PARSE(tokens)                                // abstract-syntax tree

    // ── 5. Семантика (типы, шаблоны, constexpr) ──────────────────────────
    symtab ← ANALYZE_SEMANTICS(ast)

    // ── 6. Построение графов функций (SSA-CFG) ───────────────────────────
    func_nodes ← ast.GET_FUNCTION_NODES()
    cfg_list ← PARALLEL_MAP(func_nodes, BUILD_CFG)  

    // ── 7. Оптимизация графов (склейка, DCE, SSA-упрощения) ──────────────
    FOR_EACH(cfg IN cfg_list)
        OPTIMIZE_CFG(cfg)                            
    END FOR

    // ── 8. Слияние модульных графов при необходимости ───────────────────
    module_graph ← MERGE_CFG_LIST(cfg_list)

    // ── 9. Экспорт (JSON / Protobuf / DOT) ───────────────────────────────
    EXPORT_GRAPH(module_graph, out_path)

    TIMER_STOP(T_total)
    PRINT("Build finished in", T_total, "ms")
end procedure
```

