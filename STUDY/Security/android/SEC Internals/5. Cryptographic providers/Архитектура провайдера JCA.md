
> [!new] 
> Java Cryptography Architecture (JCA) - расширяемая архитектура криптографических провайдеров и набор API, охватывающих основные примитивы, используемые сегодня (блочные, дайджесты сообщений, цифровые подписи и т.д.). Фактически это даёт независимость от реализации и расширяемость. 

> [!security] 
> Приложения, использующие API JCA, обычно только указывают протокол, который они хотят использовать и не зависят от конкретной реализации провайдера. Поддержка новых протоколов может быть добавлена регистрацией нового провайдера (реализующего необходимые алгоритмы).
> Кроме того, криптографические службы, реализуемые различными провайдерами, обычно совместимы (если ключи защищены аппаратно или материал ключа не доступен напрямую) и приложения, в силу этого, могут комбинировать различные службы различных провайдеров при необходимости. 
> 

---
## Криптографические сервис-провайдеры

> [!fact] 
> JCA разделяет криптографические функции на ряд абстрактных криптографических сервисов, называемых двигателями (**`engines`**), и определяет API для каждого запроса в виде класса двигателя.
> Например, цифровые подписи представлены классом `Signature`, а шифрование классом `Cipher`.
> 

В контексте JCA криптографический сервис-провайдер (CSP, или просто провайдер) — это пакет (или набор пакетов), который предоставляет конкретную реализацию определенных криптографических сервисов. Каждый провайдер рекламирует сервисы и алгоритмы, которые он реализует, позволяя фреймворку JCA поддерживать реестр поддерживаемых алгоритмов и их реализующих провайдеров. Этот реестр поддерживает порядок предпочтений для провайдеров, поэтому если определенный алгоритм предлагается несколькими провайдерами, возвращается тот, который имеет более высокий порядок предпочтений. Исключение из этого правила делается для классов двигателей, которые поддерживают отложенный выбор провайдера (Cipher, KeyAgreement, Mac и Signature). При отложенном выборе провайдера провайдер выбирается не в момент создания экземпляра класса двигателя, а когда класс двигателя инициализируется для конкретной криптографической операции. Инициализация требует экземпляра `Key`, который система использует для поиска провайдера, который может принять указанный объект `Key`. Отложенный выбор провайдера полезен при использовании ключей, хранящихся в аппаратном обеспечении, потому что система не может найти аппаратно поддерживаемого провайдера, основываясь только на имени алгоритма. Однако конкретные экземпляры `Key`, передаваемые методам инициализации, обычно имеют достаточно информации для определения основного провайдера.

Пример конфигурации провайдера
Рассмотрим пример использования конфигурации провайдера, иллюстрируемой на Рисунке 5-1.

![[Pasted image 20240804215809.png]]
**Рисунок 5-1**: Выбор реализации алгоритма JCA при отсутствии указания провайдера

```java
MessageDigest md = MessageDigest.getInstance("SHA-256");
```
Листинг 5-1: Запрос реализации SHA-256 без указания провайдера

С другой стороны, если приложение специально запрашивает `ProviderC` (как показано в Листинге 5-2), его реализация будет возвращена, даже если `ProviderB` имеет более высокий порядок предпочтений.

```java
MessageDigest md = MessageDigest.getInstance("SHA-256", "ProviderC");
```
Листинг 5-2: Запрос реализации SHA-256 от конкретного провайдера

В общем, приложения не должны явно запрашивать провайдера, если они не включают запрашиваемого провайдера как часть приложения или не могут обработать резервный вариант, если предпочтительный провайдер недоступен.

---
## Реализация провайдера

> [!important]
> Фреймворк JCA (Java Cryptography Architecture) обеспечивает независимость реализации, требуя, чтобы все реализации конкретного криптографического сервиса или алгоритма соответствовали общему интерфейсу. Для каждого класса двигателя, представляющего конкретный криптографический сервис, фреймворк определяет соответствующий абстрактный класс ***Service Provider Interface (SPI)***. Провайдеры, которые предлагают определенный криптографический сервис, реализуют и рекламируют соответствующий класс SPI.

> [!example] 
> Например, провайдер, который реализует данный алгоритм шифрования, должен иметь реализацию класса `CipherSpi`, который соответствует классу двигателя `Cipher`. Когда приложение вызывает фабричный метод `Cipher.getInstance()`, фреймворк JCA находит подходящего провайдера, используя процесс, описанный в разделе "Cryptographic Service Providers", и возвращает экземпляр `Cipher`, который маршрутизирует все свои вызовы методов к подклассу `CipherSpi`, реализованному в выбранном провайдере.

Помимо классов реализации SPI, каждый провайдер имеет подкласс абстрактного класса `java.security.Provider`, который определяет имя и версию провайдера и, что более важно, список поддерживаемых алгоритмов и соответствующих классов реализации SPI. Фреймворк провайдера JCA использует этот класс `Provider` для построения реестра провайдеров и обращается к нему при поиске реализаций алгоритмов для возврата своим клиентам.

**Определение класса провайдера**:
```java
public class MyProvider extends Provider {
    public MyProvider() {
        super("MyProvider", 1.0, "MyProvider v1.0, implementing AES encryption");
        put("Cipher.AES", "com.example.crypto.AESCipherSpi");
    }
}
```

**Реализация класса SPI**:
```java
public class AESCipherSpi extends CipherSpi {
    @Override
    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
        // Реализация настройки режима шифрования
    }

    @Override
    protected void engineSetPadding(String padding) throws NoSuchPaddingException {
        // Реализация настройки заполнения
    }

    @Override
    protected int engineGetBlockSize() {
        // Возвращает размер блока шифра
        return 16; // Например, для AES
    }

    @Override
    protected int engineGetOutputSize(int inputLen) {
        // Возвращает размер выходных данных
        return inputLen + (16 - (inputLen % 16)); // Например, для AES
    }

    @Override
    protected byte[] engineGetIV() {
        // Возвращает вектор инициализации (IV)
        return new byte[16];
    }

    @Override
    protected AlgorithmParameters engineGetParameters() {
        // Возвращает параметры алгоритма
        return null;
    }

    @Override
    protected void engineInit(int opmode, Key key, SecureRandom random) throws InvalidKeyException {
        // Инициализация шифра с ключом и случайным числом
    }

    @Override
    protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
        // Инициализация шифра с ключом и параметрами алгоритма
    }

    @Override
    protected void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
        // Инициализация шифра с ключом и параметрами алгоритма
    }

    @Override
    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {
        // Обновление данных шифрования
        return new byte[inputLen];
    }

    @Override
    protected int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException {
        // Обновление данных шифрования с указанием выходного буфера
        System.arraycopy(input, inputOffset, output, outputOffset, inputLen);
        return inputLen;
    }

    @Override
    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException {
        // Финализация шифрования и возврат зашифрованных данных
        return new byte[inputLen];
    }

    @Override
    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException {
        // Финализация шифрования с указанием выходного буфера
        System.arraycopy(input, inputOffset, output, outputOffset, inputLen);
        return inputLen;
    }
}

```

---
## Статическая регистрация провайдера


> [!tip] 
> Для того чтобы провайдер был виден фреймворку JCA, он должен быть сначала зарегистрирован. Существуют два способа регистрации провайдеров: статический и динамический. Статическая регистрация требует редактирования файла системных настроек безопасности и добавления записи для провайдера.
> В Android этот файл настроек называется `security.properties` и присутствует только внутри системной библиотеки `core.jar`. Поэтому его нельзя редактировать и статическая регистрация провайдеров не поддерживается.

Запись провайдера в файле настроек безопасности форматируется, как показано в Листинге 5-3.
```plaintext
security.provider.n=ProviderClassName
```
Листинг 5-3: Статическая регистрация провайдера JCA

Здесь `n` — это порядок предпочтения провайдера, который используется при поиске запрашиваемых алгоритмов (когда имя провайдера не указано). Порядок начинается с 1; то есть 1 — это самый предпочтительный, за ним следует 2 и так далее. `ProviderClassName` — это имя класса `java.security.Provider`, описанного в разделе "Provider Implementation".

---
## Динамическая регистрация провайдеров


> [!new] 
> Провайдеры регистрируются динамически (во время выполнения) с помощью методов `addProvider()` или `insertProviderAt()` класса `java.security.Security` и возвращают фактическое размещение этого провайдера или -1, если провайдер не был добавлен из-за того, что уже установлен.
> Удаление провайдера возможно с помощью метода `removeProvider()`.

Класс `Security` управляет списком провайдеров безопасности и фактически действует как реестр провайдеров, описанный в предыдущих разделах. В Java SE программы требуют специальных разрешений для регистрации провайдеров и изменения реестра провайдеров, поскольку вставка нового провайдера в начало списка провайдеров может эффективно заменить системную реализацию безопасности.

> [!security] 
> Android изменения в реестре провайдеров ограничены текущим процессом приложения и не могут влиять на систему или другие приложения. Поэтому для регистрации JCA провайдера не требуются специальные разрешения.

Динамические изменения в реестре провайдеров обычно помещаются в статический блок, чтобы гарантировать их выполнение до любого кода приложения. Листинг 5-4 показывает пример замены провайдера по умолчанию (с наивысшим приоритетом) на пользовательский.

```java
static {
    Security.insertProviderAt(new MyProvider(), 1);
}
```
Листинг 5-4: Динамическая вставка пользовательского JCA провайдера

> [!note]
> Если класс загружается более одного раза (например, разными загрузчиками классов), статический блок может быть выполнен несколько раз. Вы можете обойти это, проверяя, доступен ли уже провайдер, или используя класс-хранитель, который загружается только один раз.

---
---
Следующая глава [[Классы двигателей JCA]]
Раздел [[Cryptographic providers]]
Книга [[SEC Internals]]