> [!list]
> Класс двигателя (engine class) предоставляет интерфейс для конкретного типа криптографического сервиса. Двигатели JCA (Java Cryptography Architecture) предоставляют один из следующих сервисов:
> - **Криптографические операции** (шифрование/дешифрование, подпись/проверка, хеширование и т.д.)
> - **Генерация или преобразование криптографического материала** (ключи и параметры алгоритмов)
> - **Управление и хранение криптографических объектов**, таких как ключи и цифровые сертификаты

---
## Получение экземпляра класса двигателя

> [!warning]
> Помимо предоставления единого интерфейса для криптографических операций, классы двигателей (engine classes) JCA разделяют клиентский код и реализацию, поэтому их нельзя создавать напрямую. Вместо этого они предоставляют статический фабричный метод `getInstance()`, который позволяет запрашивать реализацию косвенно. Метод `getInstance()` обычно имеет одну из следующих сигнатур, показанных в Листинге 5-5.

```java
static EngineClassName getInstance(String algorithm)
    throws NoSuchAlgorithmException
static EngineClassName getInstance(String algorithm, String provider)
    throws NoSuchAlgorithmException, NoSuchProviderException
static EngineClassName getInstance(String algorithm, Provider provider)
    throws NoSuchAlgorithmException
```

Обычно используется сигнатура под номером `u`, где указывается только имя алгоритма. Сигнатуры под номерами `v` и `w` позволяют запрашивать реализацию у конкретного провайдера. Все варианты выбрасывают исключение `NoSuchAlgorithmException`, если реализация для запрашиваемого алгоритма недоступна, и сигнатура под номером `v` выбрасывает исключение `NoSuchProviderException`, если провайдер с указанным именем не зарегистрирован.

---
## Имена алгоритмов

> [!security] 
> Строковый параметр `algorithm`, который принимают все фабричные методы, соответствует определенному криптографическому алгоритму или трансформации, либо указывает стратегию реализации для объектов более высокого уровня, которые управляют коллекциями сертификатов или ключей. Обычно сопоставление прямолинейное. Например, `SHA-256` соответствует реализации алгоритма хеширования `SHA-256`, а `AES` запрашивает реализацию алгоритма шифрования `AES`. Однако некоторые имена алгоритмов имеют структуру и указывают более одного параметра запрашиваемой реализации. Например, `SHA256withRSA` указывает реализацию подписи, которая использует `SHA-256` для хеширования подписываемого сообщения и `RSA` для выполнения операции подписи. У алгоритмов также могут быть псевдонимы, и более одного имени алгоритма могут соответствовать одной и той же реализации.

Вы можете использовать код, приведенный в Листинге 5-6, чтобы перечислить всех провайдеров, имена алгоритмов криптографических сервисов, предлагаемых каждым провайдером, и классы реализации, к которым они соответствуют.
```java
Provider[] providers = Security.getProviders();
for (Provider p : providers) {
    System.out.printf("%s/%s/%f\n", p.getName(), p.getInfo(), p.getVersion());
    Set<Provider.Service> services = p.getServices();
    for (Provider.Service s : services) {
        System.out.printf("\t%s/%s/%s\n", s.getType(), s.getAlgorithm(), s.getClassName());
    }
}
```
Листинг 5-6: Перечисление всех провайдеров JCA и поддерживаемых ими алгоритмов

---
## SecureRandom

> [!new] 
> Класс `SecureRandom` представляет собой криптографически безопасный генератор случайных чисел. Напрямую он почти не используется, однако внутри системы с его помощью реализуется генерация ключей и другого криптографического материала. 

> [!info] 
> Типичная реализация обычно представляет собой криптографически безопасный генератор **псевдо**случайных чисел на основе семени (seed). Поскольку качество сгенерированных чисел зависит по большей части от семени, оно выбирается тщательно, обычно на основе действительно случайного числа.
> 

> [!important] 
> На Android реализации CSPRNG получают начальные байты, считывая их из `/dev/urandom`, являющимся в своей сути интерфейсом к CSPRNG ядра.
> 

> [!important] 
> Поскольку сам CSPRNG может находится в достаточно предсказуемом состояние сразу после запуска, Android периодически сохраняет состояние CSPRNG ядра в файл `/data/system/entropy.dat`. Содержимое этого файла записывается обратно в `/dev/urandom` при загрузке для переноса предыдущего состояния CSPRNG. Всё это выполняется службой `EntropyMixer`.


> [!fact] 
> В отличие от большинства классов двигателей, `SecureRandom` имеет публичные конструкторы, которые вы можете использовать для создания экземпляров.
> Рекомендуемый способ создания такового - использовать конструктор по умолчанию.

> [!faq] 
> Если вы используете фабричный метод `getInstance()`, вам нужно передать `SHA1PRNG` как имя алгоритма, который является единственным универсально поддерживаемым именем алгоритма для `SecureRandom`. Поскольку `SHA1PRNG` не является точно криптографическим стандартом, реализации от разных провайдеров могут работать по-разному.

Для генерации случайных байтов с помощью `SecureRandom` вы передаете массив байтов в метод `nextBytes()` (`v` в Листинге 5-7). Он сгенерирует столько байтов, сколько длина массива (16 в Листинге 5-7), и сохранит их в нем.
```java
SecureRandom sr = new SecureRandom();u
byte[] output = new byte[16];
sr.nextBytes(output);v
```
Листинг 5-7: Использование `SecureRandom` для генерации случайных байтов

> [!security] 
> Ручное задание семени для `SecureRandom` не рекомендуется, поскольку неправильное задание семени для системного CSPRNG может привести к его производству предсказуемой последовательности байтов, что может поставить под угрозу любые операции более высокого уровня, требующие случайного ввода.

> [!danger] 
> Однако, если вам по какой-либо причине нужно вручную задать семя для `SecureRandom` (например, если известно, что стандартная реализация инициализации системы имеет недостатки), вы можете сделать это с помощью конструктора `SecureRandom(byte[] seed)` или вызвав метод `setSeed()`. При ручном задании семени убедитесь, что используемое семя достаточно случайно; например, путем чтения его из `/dev/urandom`.

> [!fail] 
> Кроме того, в зависимости от базовой реализации, вызов `setSeed()` может не заменить, а только добавить к внутреннему состоянию CSPRNG; поэтому два экземпляра `SecureRandom`, заданные одним и тем же значением семени, могут не производить одну и ту же последовательность чисел. Поэтому `SecureRandom` не следует использовать, когда требуются детерминированные значения. Вместо этого используйте криптографический примитив, предназначенный для создания детерминированного вывода из данного ввода, такой как алгоритм хеширования или функция вывода ключа.

---
## MessageDigest

> [!info] 
> Класс `MessageDigest` представляет собой функциональность криптографической хеш-функции, также называемой функцией дайджеста сообщений. 
> Криптографическая хеш-функция принимает произвольно длинную последовательность байтов и генерирует фиксированную по размеру последовательность байтов, называемую дайджестом или хешем.

Пример использования `MessageDigest`
```java
MessageDigest md = MessageDigest.getInstance("SHA-256"); // Получение экземпляра MessageDigest с алгоритмом SHA-256
byte[] data = getMessage(); // Получение данных для хеширования
byte[] digest = md.digest(data); // Хеширование данных и получение дайджеста
```
Листинг 5-8: Использование `MessageDigest` для хеширования данных

> [!help] 
> Экземпляр `MessageDigest` создается путем передачи имени алгоритма хеширования в фабричный метод `getInstance()` (`u`). Входные данные могут быть предоставлены частями, используя один из методов `update()`, а затем вызов одного из методов `digest()` для получения рассчитанного значения хеша. Альтернативно, если размер входных данных фиксирован и относительно короткий, его можно захешировать за один шаг, используя метод `digest(byte[] input)` (`v`), как показано в Листинге 5-8.

---
## Signature

> [!new] 
> Класс `Signature` предоставляет общий интерфейс для алгоритмов цифровой подписи, основанных на асимметричном шифровании. Алгоритм цифровой подписи принимает произвольное сообщение и закрытый ключ, генерируя фиксированный по размеру байтовый массив, называемый подписью.

Алгоритмы цифровой подписи обычно применяют алгоритм дайджеста к входному сообщению, кодируют рассчитанное значение хеша, а затем используют операцию закрытого ключа для создания подписи. Подпись затем может быть проверена с помощью соответствующего открытого ключа, применяя обратную операцию, вычисляя значение хеша подписанного сообщения и сравнивая его с тем, которое закодировано в подписи. Успешная проверка гарантирует целостность подписанного сообщения и, при условии, что закрытый ключ оставался действительно приватным, его подлинность.

> [!help]
> Экземпляры `Signature` создаются с помощью стандартного фабричного метода `getInstance()`. Имя алгоритма обычно имеет форму `<digest>with<encryption>`, где `<digest>` - это имя алгоритма хеширования, используемого в `MessageDigest` (например, SHA256), а `<encryption>` - это асимметричный алгоритм шифрования (например, RSA или DSA).

Например, `SHA512withRSA` сначала использует алгоритм хеширования SHA-512 для создания значения дайджеста, а затем шифрует закодированный дайджест с помощью закрытого ключа RSA для создания подписи. Для алгоритмов подписи, использующих функцию генерации маски, таких как RSA-PSS, имя алгоритма имеет форму `<digest>with<encryption>and<mgf>` (например, `SHA256withRSAandMGF1`).

Пример использования класса `Signature`
```java
PrivateKey privKey = getPrivateKey(); // Получение закрытого ключа
PublicKey pubKey = getPublicKey(); // Получение открытого ключа
byte[] data = "sign me".getBytes("ASCII"); // Данные для подписи
Signature sig = Signature.getInstance("SHA256withRSA"); // Создание экземпляра Signature для алгоритма SHA256withRSA
sig.initSign(privKey); // Инициализация для подписи с закрытым ключом (u)
sig.update(data); // Обновление данных для подписи (v)
byte[] signature = sig.sign(); // Создание подписи (w)
sig.initVerify(pubKey); // Инициализация для проверки с открытым ключом (x)
sig.update(data); // Обновление данных для проверки
boolean valid = sig.verify(signature); // Проверка подписи (y)
```
Листинг 5-9: Создание и проверка подписи с помощью класса `Signature`

После получения экземпляра объект `Signature` инициализируется либо для подписывания, передавая закрытый ключ в метод `initSign()` (`u` в Листинге 5-9), либо для проверки, передавая открытый ключ или сертификат в метод `initVerify()` (`x`). Подписание похоже на вычисление хеша с `MessageDigest`: данные для подписи передаются частями в один из методов `update()` (`v`) или целиком в метод `sign()` (`w`), который возвращает значение подписи. Для проверки подписи подписанные данные передаются в один из методов `update()`. Наконец, подпись передается в метод `verify()` (`y`), который возвращает `true`, если подпись действительна.

---
## Cipher

> [!new] 
> Класс `Cipher` предоставляет общий интерфейс для операций шифрования и дешифрования.

В зависимости от того, как они обрабатывают входные данные, шифры могут быть блочными или потоковыми. Блочные шифры работают с фиксированными по размеру кусками данных, называемыми блоками. Если входные данные не могут быть разделены на целое число блоков, последний блок заполняется, добавляя необходимое количество байтов, чтобы соответствовать размеру блока. Как операция, так и добавленные байты называются заполнением (padding). Заполнение удаляется в процессе дешифрования и не включается в расшифрованный открытый текст. Если алгоритм заполнения указан, класс `Cipher` может автоматически добавлять и удалять заполнение. С другой стороны, потоковые шифры обрабатывают входные данные по одному байту (или даже биту) за раз и не требуют заполнения.

---
### Режимы работы блочных шифров

> [!info] 
> Блочные шифры используют различные стратегии при обработке входных блоков для создания окончательного шифротекста (или открытого текста при дешифровании). Эти стратегии называются режимами работы, режимами шифрования или просто режимами.

> [!important] 
> Самая простая стратегия обработки заключается в разбиении открытого текста на блоки (с добавлением заполнения при необходимости), применении шифра к каждому блоку и затем объединении зашифрованных блоков для создания шифротекста. Этот режим называется режимом электронной кодовой книги (Electronic Code Book, ECB), и, хотя он прост и удобен в использовании, у него есть серьезный недостаток: одинаковые блоки открытого текста производят одинаковые блоки шифротекста.

Таким образом, структура открытого текста отражается в шифротексте, что компрометирует конфиденциальность сообщения и облегчает криптоанализ. Это часто иллюстрировалось печально известным "Пингвином ECB" из статьи Википедии о режимах работы блочных шифров. Представляем нашу версию для Android на рисунке 5-2. Здесь:
- u — это оригинальное изображение,
- v — изображение, зашифрованное в режиме ECB,
- w — то же изображение, зашифрованное в режиме CBC. Как видно, рисунок оригинального изображения различим в v, тогда как w выглядит как случайный шум.

![[Pasted image 20240806164559.png]]
Рисунок 5-2: Шаблоны шифротекста, созданные различными режимами шифрования

> [!important] 
> Режимы обратной связи добавляют случайность в шифротекст, комбинируя предыдущий зашифрованный блок с текущим блоком открытого текста перед шифрованием. Чтобы создать первый блок шифра, они комбинируют первый блок открытого текста с блочным набором байтов, не найденным в оригинальном открытом тексте, который называется вектором инициализации (IV).

> [!security] 
> Когда класс `Cipher` настроен на использование режима обратной связи, он может использовать IV, указанный клиентом, или генерировать его автоматически. Обычно используемые режимы обратной связи: цепное блочное шифрование (Cipher-block chaining, CBC), обратная связь по шифру (Cipher feedback, CFB) и обратная связь по выходу (Output feedback, OFB).

> [!security] 
> Еще один способ добавить случайность в шифротекст, используемый в режиме счетчика (Counter, CTR), заключается в шифровании последовательных значений последовательности счетчика для создания нового ключа для каждого блока открытого текста, который нужно зашифровать. Это эффективно превращает базовый блочный шифр в потоковый шифр, и заполнение не требуется.

> [!bug] 
> Новые режимы шифрования, такие как режим Галуа/счетчика (Galois/Counter Mode, GCM), не только рассеивают шаблоны в оригинальном открытом тексте, но и аутентифицируют шифротекст, гарантируя, что он не был подделан. Они обеспечивают аутентифицированное шифрование (Authenticated Encryption, AE) или аутентифицированное шифрование с ассоциированными данными (Authenticated Encryption with Associated Data, AEAD).

API `Cipher` были расширены для поддержки аутентифицированного шифрования в Java SE 7, и эти расширения доступны с Android 4.4, который имеет библиотеку API, совместимую с Java 7. AE шифры объединяют тег аутентификации, созданный операцией шифрования, с шифротекстом, который эта операция производит, для формирования их окончательного вывода. В API `Cipher` тег включается (или проверяется при дешифровании) неявно после вызова `doFinal()`, поэтому не следует использовать вывод `update()`, пока вы не убедитесь, что неявный тег в конце валиден.

---
### Получение экземпляра Cipher

> [!help] 
> Рассмотрев основные параметры шифра, мы наконец можем обсудить, как создавать экземпляры `Cipher`. Как и другие классы движков, объекты `Cipher` создаются с помощью фабричного метода `getInstance()`, который требует не просто простого имени алгоритма, но и полного указания криптографической трансформации, которую будет выполнять запрашиваемый шифр.

Листинг 5-10 показывает, как создать экземпляр `Cipher`, передав строку трансформации в `getInstance()`.
```java
Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
```
Листинг 5-10: Создание экземпляра `Cipher`

> [!example] 
> Трансформация должна указывать алгоритм шифрования, режим шифрования и заполнение. Строка трансформации, передаваемая в `getInstance()`, имеет формат `алгоритм/режим/заполнение`. Например, строка трансформации, использованная в Листинге 5-10, создаст экземпляр `Cipher`, который использует AES в качестве алгоритма шифрования, CBC в качестве режима шифрования и PKCS#5 в качестве заполнения.

> [!danger] 
> Экземпляр `Cipher` можно создать, передав только имя алгоритма, но в этом случае возвращаемая реализация будет использовать специфичные для провайдера значения по умолчанию для режима шифрования и заполнения. Это не только не переносимо между провайдерами, но и может серьезно повлиять на безопасность системы, если, например, во время выполнения будет использован менее безопасный, чем предполагалось, режим шифрования (например, ECB). Этот "ярлык" является серьезным недостатком конструкции фреймворка провайдеров JCA и никогда не должен использоваться.


---
### Использование Cipher

> [!help] 
> После получения экземпляра `Cipher` его необходимо инициализировать перед шифрованием или дешифрованием данных. `Cipher` инициализируется путём передачи целочисленной константы, обозначающей режим операции (`ENCRYPT_MODE`, `DECRYPT_MODE`, `WRAP_MODE` или `UNWRAP_MODE`), ключа или сертификата и, при необходимости, параметров алгоритма в один из соответствующих методов `init()`. 

Режимы `ENCRYPT_MODE` и `DECRYPT_MODE` используются для шифрования и дешифрования произвольных данных, в то время как `WRAP_MODE` и `UNWRAP_MODE` являются специализированными режимами, используемыми при шифровании (обертывании) и дешифровании (разворачивании) ключевого материала объекта `Key` с помощью другого ключа.

Листинг 5-11: Использование класса `Cipher` для шифрования и дешифрования данных

```java
SecureRandom sr = new SecureRandom();
SecretKey key = getSecretKey();
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

byte[] iv = new byte[cipher.getBlockSize()];
sr.nextBytes(iv);
IvParameterSpec ivParams = new IvParameterSpec(iv);
cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);
byte[] plaintext = "encrypt me".getBytes("UTF-8");
ByteArrayOutputStream baos = new ByteArrayOutputStream();
byte[] output = cipher.update(plaintext);
if (output != null) {
    baos.write(output);
}
output = cipher.doFinal();
baos.write(output);
byte[] ciphertext = baos.toByteArray();
cipher.init(Cipher.DECRYPT_MODE, key, ivParams);
baos = new ByteArrayOutputStream();
output = cipher.update(ciphertext);
if (output != null) {
    baos.write(output);
}

output = cipher.doFinal();
baos.write(output);
byte[] decryptedPlaintext = baos.toByteArray();
```

---
## Mac (не ноутбук)

> [!new] 
> Класс `Mac` предоставляет общий интерфейс для алгоритмов кода аутентификации сообщений (Message Authentication Code, MAC).

> [!important] 
> MAC используется для проверки целостности сообщений, передаваемых по ненадежному каналу. Алгоритмы MAC используют секретный ключ для вычисления значения, MAC (также называемого тегом), которое можно использовать для аутентификации сообщения и проверки его целостности. Тот же ключ используется для выполнения проверки, поэтому его необходимо передать между сторонами, участвующими в обмене сообщениями. (MAC часто комбинируется с шифром для обеспечения конфиденциальности и целостности.)

```java
KeyGenerator keygen = KeyGenerator.getInstance("HmacSha256");
SecretKey key = keygen.generateKey();
Mac mac = Mac.getInstance("HmacSha256");
mac.init(key);v
byte[] message = "MAC me".getBytes("UTF-8");
byte[] tag = mac.doFinal(message);
```

---
## Ключ

> [!new] 
> Интерфейс `Key` представляет собой непрозрачные ключи в рамках JCA. Непрозрачные ключи могут использоваться в криптографических операциях, но обычно не предоставляют доступ к исходному ключевому материалу (сырым байтам ключа). Это позволяет использовать одни и те же классы и интерфейсы JCA как с программными реализациями криптографических алгоритмов, которые хранят ключевой материал в памяти, так и с аппаратно защищенными, где ключевой материал может находиться в аппаратном токене (смарт-карте, HSM и т. д.) и не доступен напрямую.

Интерфейс `Key` определяет всего три метода:

1. **`String getAlgorithm()`**
    
    - Возвращает название алгоритма шифрования (симметричного или асимметричного), с которым может использоваться этот ключ. Примеры: AES или RSA.
2. **`byte[] getEncoded()`**
    
    - Возвращает стандартную закодированную форму ключа, которую можно использовать при передаче ключа другим системам. Это может быть зашифровано для закрытых ключей. Для аппаратно защищенных реализаций, которые не допускают экспорт ключевого материала, этот метод обычно возвращает null.
3. **`String getFormat()`**
    
    - Возвращает формат закодированного ключа. Это обычно RAW для ключей, которые не закодированы в каком-либо определенном формате. Другие форматы, определенные в JCA, это X.509 и PKCS#8.

Вы можете получить экземпляр `Key` следующими способами:

- Генерация ключей с помощью `KeyGenerator` или `KeyPairGenerator`.
- Преобразование из закодированного представления с помощью `KeyFactory`.
- Извлечение сохраненного ключа из `KeyStore`.

---
## SecretKey и PBEKey

> [!new] 
> Интерфейс `SecretKey` представляет ключи, используемые в симметричных алгоритмах. Это интерфейс-маркер, который не добавляет никаких методов к методам родительского интерфейса `Key`. Он имеет только одну реализацию, которую можно напрямую создавать, а именно `SecretKeySpec`. Этот класс является как реализацией ключа, так и спецификацией ключа (как обсуждается в разделе "KeySpec"), и позволяет создавать экземпляры `SecretKey` на основе исходного ключевого материала.

Подинтерфейс `PBEKey` представляет ключи, полученные с использованием шифрования на основе пароля (Password Based Encryption, PBE). PBE определяет алгоритмы, которые генерируют сильные криптографические ключи из паролей и фраз-паролей, которые обычно имеют низкую энтропию и поэтому не могут быть использованы напрямую в качестве ключей. PBE основан на двух основных идеях: использование соли для защиты от атак с использованием предвычисленных таблиц (salting) и использование большого числа итераций, чтобы сделать процесс генерации ключа вычислительно затратным (key stretching). Соль и количество итераций используются в качестве параметров для алгоритмов PBE и, следовательно, должны быть сохранены для генерации того же ключа из определенного пароля. Таким образом, реализации `PBEKey` должны реализовывать методы `getSalt()`, `getIterationCount()` и `getPassword()`.

---
## PublicKey, PrivateKey и KeyPair

> [!new] 
> Публичные и приватные ключи для асимметричных алгоритмов шифрования моделируются интерфейсами `PublicKey` и `PrivateKey`. Они являются маркерными интерфейсами и не добавляют новых методов. JCA определяет специализированные классы для конкретных асимметричных алгоритмов, которые содержат параметры соответствующих ключей, такие как `RSAPublicKey` и `RSAPrivateCrtKey`. Интерфейс `KeyPair` представляет собой просто контейнер для публичного и приватного ключей.

---
## KeySpec

> [!new] 
> Интерфейс `Key` в JCA представляет непрозрачные ключи. С другой стороны, `KeySpec` моделирует спецификацию ключа, которая является прозрачным представлением ключа и позволяет вам получить доступ к отдельным параметрам ключа. На практике большинство интерфейсов `Key` и `KeySpec` для конкретных алгоритмов значительно пересекаются, поскольку параметры ключа должны быть доступны для реализации алгоритмов шифрования.

Например, и `RSAPrivateKey`, и `RSAPrivateKeySpec` определяют методы `getModulus()` и `getPrivateExponent()`. Различие становится важным только тогда, когда алгоритм реализован в аппаратуре, в этом случае `KeySpec` будет содержать только ссылку на аппаратно управляемый ключ, а не сами параметры ключа. Соответствующий ключ (`Key`) будет содержать дескриптор аппаратно управляемого ключа и может быть использован для выполнения криптографических операций, но не будет содержать сам ключевой материал.
Например, `RSAPrivateKey`, который хранится в аппаратуре, вернет `null`, когда будет вызван его метод `getPrivateExponent()`.

Реализации `KeySpec` могут содержать закодированное представление ключа, в этом случае они не зависят от алгоритма.
С другой стороны, специфический для алгоритма `KeySpec` содержит все параметры ключа в виде полей. Например, `RSAPrivateKeySpec` содержит модуль и приватную экспоненту для ключа RSA, которые могут быть получены с помощью методов `getModulus()` и `getPrivateExponent()`, соответственно. Независимо от их типа, `KeySpecs` преобразуются в объекты `Key` с использованием `KeyFactory`.

---
## KeyFactory

> [!new] 
> `KeyFactory` инкапсулирует процедуру преобразования, необходимую для превращения прозрачного представления публичного или приватного ключа (некоторого подкласса `KeySpec`) в непрозрачный объект ключа (некоторого подкласса `Key`), который может быть использован для выполнения криптографической операции, или наоборот. `KeyFactory`, который преобразует закодированный ключ, обычно анализирует данные закодированного ключа и сохраняет каждый параметр ключа в соответствующем поле конкретного класса `Key`.

Например, чтобы разобрать RSA публичный ключ, закодированный в формате X.509, можно использовать следующий код (см. листинг 5-13).
```java
KeyFactory kf = KeyFactory.getInstance("RSA");
byte[] encodedKey = readRsaPublicKey();
X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);
RSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(keySpec);
```
Листинг 5-13: Использование `KeyFactory` для преобразования закодированного в формате X.509 ключа в объект `RSAPublicKey`

Здесь мы создаем `RSA KeyFactory`, передавая `RSA` в `KeyFactory.getInstance()`. Затем мы читаем закодированный RSA ключ, используем байты закодированного ключа для создания `X509EncodedKeySpec`, и, наконец, передаем `KeySpec` в метод `generatePublic()` фабрики, чтобы получить экземпляр `RSAPublicKey`.

`KeyFactory` также может преобразовывать специфический для алгоритма `KeySpec`, такой как `RSAPrivateKeySpec`, в соответствующий экземпляр ключа (в данном случае `RSAPrivateKey`), но в этом случае он просто копирует параметры ключа (или дескриптор ключа) из одного класса в другой. Вызов метода `KeyFactory.getKeySpec()` преобразует объект ключа в `KeySpec`, но это использование не очень распространено, так как закодированное представление ключа можно получить просто вызвав `getEncoded()` напрямую на объекте ключа, а специфические для алгоритма `KeySpecs` обычно не предоставляют больше информации, чем конкретный класс `Key`.

> [!important] 
> Еще одной особенностью `KeyFactory` является преобразование экземпляра ключа из другого провайдера в соответствующий объект ключа, совместимый с текущим провайдером. Эта операция называется трансляцией ключа и выполняется с помощью метода `translateKey(Key key)`.

---
## SecretKeyFactory

> [!new] 
> `SecretKeyFactory` очень похож на `KeyFactory`, за исключением того, что он работает только с секретными (симметричными) ключами. Вы можете использовать его для преобразования спецификации симметричного ключа в объект ключа и наоборот. Однако на практике, если у вас есть доступ к материалу ключа симметричного ключа, намного проще использовать его для непосредственного создания `SecretKeySpec`, который также является ключом, поэтому такой способ используется не очень часто.

Гораздо более распространенный случай использования — это генерация симметричного ключа из пароля, введенного пользователем, с использованием PBE (см. листинг 5-14).
```java
byte[] salt = generateSalt();
int iterationCount = 1000;
int keyLength = 256;
KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);
SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
SecretKey key = skf.generateSecret(keySpec);
```
Листинг 5-14: Генерация секретного ключа из пароля с использованием `SecretKeyFactory`

В этом случае `PBEKeySpec` инициализируется паролем, случайно сгенерированной солью, количеством итераций и желаемой длиной ключа. Затем с помощью вызова `getInstance()` получается фабрика секретных ключей, которая реализует алгоритм извлечения ключа PBE (в данном случае, PBKDF2). Передача `PBEKeySpec` в `generateSecret()` выполняет алгоритм извлечения ключа и возвращает экземпляр `SecretKey`, который может быть использован для шифрования или дешифрования.

---
## KeyPairGenerator

> [!new] 
> Класс `KeyPairGenerator` генерирует пары публичных и приватных ключей. 
> 

`KeyPairGenerator` создается путем передачи имени асимметричного алгоритма в фабричный метод `getInstance()` (см. листинг 5-15).
```java
KeyPairGenerator kpg = KeyPairGenerator.getInstance("ECDH");
ECGenParameterSpec ecParamSpec = new ECGenParameterSpec("secp256r1");
kpg.initialize(ecParamSpec);
KeyPair keyPair = kpg.generateKeyPair();
```
Листинг 5-15: Инициализация `KeyPairGenerator` с параметрами, специфичными для алгоритма

> [!help] 
> Существует два способа инициализации `KeyPairGenerator`: указанием желаемого размера ключа и указанием параметров, специфичных для алгоритма. В обоих случаях вы можете дополнительно передать экземпляр `SecureRandom`, который будет использован для генерации ключей. Если указан только размер ключа, генерация ключа будет использовать параметры по умолчанию (если таковые имеются).

> [!help] 
> Чтобы указать дополнительные параметры, вы должны создать и настроить экземпляр `AlgorithmParameterSpec`, соответствующий используемому асимметричному алгоритму, и передать его методу `initialize()`, как показано в листинге 5-15.

---
## KeyGenerator

> [!new] 
> `KeyGenerator` очень похож на класс `KeyPairGenerator`, за исключением того, что он генерирует симметричные ключи. Хотя вы можете сгенерировать большинство симметричных ключей, запросив последовательность случайных байтов из `SecureRandom`, реализации `KeyGenerator` выполняют дополнительные проверки на слабые ключи и устанавливают байты четности ключа там, где это необходимо (например, для алгоритмов DES и производных). Они также могут использовать доступное криптографическое оборудование, поэтому лучше использовать `KeyGenerator`, а не генерировать ключи вручную.

Листинг 5-16 показывает, как сгенерировать ключ AES с использованием `KeyGenerator`.
```java
KeyGenerator keygen = KeyGenerator.getInstance("AES");
kg.init(256);
SecretKey key = keygen.generateKey();
```
Листинг 5-16: Генерация ключа AES с использованием `KeyGenerator`

---
## KeyAgreement

> [!new] 
> Класс `KeyAgreement` представляет собой протокол согласования ключей, который позволяет двум или более сторонам генерировать общий ключ без необходимости обмениваться секретной информацией. Хотя существует множество протоколов согласования ключей, наиболее широко используемые сегодня основаны на обмене ключами Диффи-Хеллмана (DH) — либо на исходном протоколе, основанном на криптографии дискретных логарифмов (просто известном как DH), либо на более новом варианте, основанном на криптографии эллиптических кривых (ECDH).

Обе версии протокола моделируются в JCA с использованием класса `KeyAgreement` и могут выполняться одинаково, за исключением используемых ключей. Для обеих версий каждая общающаяся сторона должна иметь пару ключей, причем обе пары ключей должны быть сгенерированы с использованием одинаковых параметров ключа (основного модуля и генератора базы для DH, и, как правило, одной и той же хорошо определенной именованной кривой для ECDH). Затем сторонам нужно только обменяться открытыми ключами и выполнить алгоритм согласования ключей для получения общего секрета.

Листинг 5-17 иллюстрирует использование класса `KeyAgreement` для генерации общего секрета с использованием ECDH.
```java
PrivateKey myPrivKey = getPrivateKey();
PublicKey remotePubKey = getRemotePubKey();
KeyAgreement keyAgreement = KeyAgreement.getInstance("ECDH");
keyAgreement.init(myPrivKey);
keyAgreement.doPhase(remotePubKey, true);
byte[] secret = keyAgreement.generateSecret();
```
Листинг 5-17: Использование `KeyAgreement` для генерации общего секрета

> [!important] 
> Листинг 5-17 показывает последовательность вызовов только для одной из сторон (A), но другая сторона (B) должна выполнить ту же последовательность, используя свой собственный закрытый ключ для инициализации соглашения и передавая открытый ключ A в `doPhase()`.

> [!danger] 
> Обратите внимание, что хотя значение (или его часть), возвращаемое `generateSecret()`, может быть использовано напрямую как симметричный ключ, предпочтительный метод заключается в использовании его в качестве входных данных для функции извлечения ключа (KDF) и использования выходных данных KDF в качестве ключей. Прямое использование сгенерированного общего секрета может привести к потере некоторой энтропии, и это ограничивает количество ключей, которые можно сгенерировать, используя одну операцию согласования ключей DH. С другой стороны, использование KDF диффундирует любую структуру, которую может иметь секрет (например, выравнивание), и позволяет генерировать несколько производных ключей путем смешивания с солью.

`KeyAgreement` имеет еще один метод `generateSecret()`, который принимает имя алгоритма в качестве параметра и возвращает экземпляр `SecretKey`, который может быть использован для инициализации `Cipher` напрямую. Если экземпляр `KeyAgreement` был создан с использованием строки алгоритма, включающей спецификацию KDF (например, ECDHwithSHA1KDF), этот метод применит KDF к общему секрету перед возвратом `SecretKey`. Если KDF не был указан, большинство реализаций просто обрезают общий секрет для получения материала ключа для возвращаемого `SecretKey`.

---
## KeyStore

> [!new] 
> JCA использует термин keystore для обозначения базы данных ключей и сертификатов. Keystore управляет несколькими криптографическими объектами, называемыми записями, каждая из которых ассоциируется с строковым псевдонимом. Класс `KeyStore` предлагает четко определенный интерфейс к keystore, который определяет три типа записей:
> - **PrivateKeyEntry**: Приватный ключ с ассоциированной цепочкой сертификатов. Для программной реализации приватный ключ обычно зашифрован и защищен паролем, заданным пользователем.
> - **SecretKeyEntry**: Секретный (симметричный) ключ. Не все реализации `KeyStore` поддерживают хранение секретных ключей.
> - **TrustedCertificateEntry**: Сертификат открытого ключа другой стороны. Такие записи часто содержат сертификаты центров сертификации (CA), которые могут использоваться для установления доверительных отношений. Keystore, содержащий только такие записи, называется truststore.

#### Типы KeyStore

> [!info] 
> Реализация `KeyStore` не обязательно должна быть постоянной, но большинство реализаций таковы. Разные реализации идентифицируются по типу keystore, который определяет хранилище и формат данных keystore, а также методы, используемые для защиты хранимых ключей. Тип `KeyStore` по умолчанию задается системным свойством `keystore.type`

> [!faq] 
> Обычно реализация `KeyStore` по умолчанию для большинства поставщиков JCA является типом keystore, который хранит свои данные в файле. Формат файла может быть собственным или основанным на общедоступном стандарте. Собственные форматы включают оригинальный формат JKS Java SE и его безопасную версию JCEKS, а также формат Bouncy Castle KeyStore (BKS), который используется по умолчанию в Android.

#### KeyStore на основе файлов PKCS#12

> [!important] 
> Наиболее широко используемый общественный стандарт, позволяющий объединять приватные ключи и ассоциированные сертификаты в одном файле, — это стандарт Personal Information Exchange Syntax (PKCS#12). Это преемник стандарта Personal Information Exchange Syntax (PFX), поэтому термины PKCS#12 и PFX используются несколько взаимозаменяемо, а файлы PKCS#12 часто называют PFX-файлами.

> [!new] 
> PKCS#12 — это контейнерный формат, который может содержать несколько встроенных объектов, таких как приватные ключи, сертификаты и даже списки отзыва сертификатов (CRL). Как и предыдущие стандарты PKCS, на которых основан PKCS#12, содержимое контейнера определяется в ASN.1 и представляет собой последовательность вложенных структур. Внутренние структуры контейнера называются SafeBags, с разными мешками, определенными для сертификатов (CertBag), приватных ключей (KeyBag) и зашифрованных приватных ключей (PKCS8ShroudedKeyBag).

Пример использования PKCS#12
```java
KeyStore keyStore = KeyStore.getInstance("PKCS12");
InputStream in = new FileInputStream("mykey.pfx");
keyStore.load(in, "password".toCharArray());
KeyStore.PrivateKeyEntry keyEntry =
(KeyStore.PrivateKeyEntry)keyStore.getEntry("mykey", null);
X509Certificate cert = (X509Certificate) keyEntry.getCertificate();
RSAPrivateKey privKey = (RSAPrivateKey) keyEntry.getPrivateKey();
```
Листинг 5-18 показывает, как получить приватный ключ и сертификат из файла PKCS#12.

![[Pasted image 20240806183936.png]]

---
## CertificateFactory и CertPath

> [!new] 
> `CertificateFactory` выступает в роли парсера сертификатов и списков отзыва сертификатов (CRL), а также может строить цепочки сертификатов из списка сертификатов. Он может читать поток, содержащий закодированные сертификаты или CRL, и выводить коллекцию (или один экземпляр) объектов `java.security.cert.Certificate` и `java.security.cert.CRL`. Обычно доступна только реализация X.509, которая парсит сертификаты и CRL формата X.509.

В Листинге 5-19 показано, как распарсить файл сертификата с использованием `CertificateFactory`.
```java
CertificateFactory cf = CertificateFactory.getInstance("X.509");
InputStream in = new FileInputStream("certificate.cer");
X509Certificate cert = (X509Certificate) cf.generateCertificate(in);
```
**Листинг 5-19**: Парсинг файла сертификата X.509 с использованием `CertificateFactory`.\

---
## CertPathValidator и CertPathBuilder

> [!new] 
> Класс `CertPathValidator` инкапсулирует алгоритм проверки цепочки сертификатов, как это определено стандартом Инфраструктуры открытых ключей (X.509) или стандартом PKIX. Мы подробнее обсуждаем PKIX и проверку цепочки сертификатов в главе 6, но в Листинге 5-20 показано, как использовать `CertificateFactory` и `CertPathValidator` для создания и проверки цепочки сертификатов.

```java
CertPathValidator certPathValidator = CertPathValidator.getInstance("PKIX");
CertificateFactory cf = CertificateFactory.getInstance("X.509");
X509Certificate[] chain = getCertChain();
CertPath certPath = cf.generateCertPath(Arrays.asList(chain));
Set<TrustAnchor> trustAnchors = getTrustAnchors();
PKIXParameters result = new PKIXParameters(trustAnchors);
PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) certPathValidator.validate(certPath, pkixParams);
```
**Листинг 5-20**: Создание и проверка цепочки сертификатов с использованием `CertPathValidator`.


---
---
Предыдущая глава [[Архитектура провайдера JCA]]
Следующая глава [[Android JCA Providers]]
Раздел [[Cryptographic providers]]
Книга [[SEC Internals]]
