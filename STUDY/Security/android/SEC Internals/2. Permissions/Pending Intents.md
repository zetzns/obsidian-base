Pending intents не являются компонентом Android или разрешением, но, поскольку они позволяют приложению передавать свои собственные разрешения другому приложению, мы обсудим их здесь.\

> [!new] 
> Pending intents инкапсулируют intent и целевое действие для выполнения с этим intent (запуск активности, отправка broadcast и т.д.). Основное отличие от "обычных" intent заключается в том, что pending intents также включают идентификацию приложения, которое их создало.

> [!important]
> Это позволяет передавать pending intents другим приложениям, которые могут использовать их для выполнения указанного действия, используя идентификацию и разрешения исходного приложения. Идентификация, хранящаяся в pending intents, гарантируется системой `ActivityManagerService`, которая отслеживает активные pending intents.

> [!todo] 
> Pending intents используются для реализации будильников и уведомлений в Android. Будильники и уведомления позволяют любому приложению указать действие, которое должно быть выполнено от его имени, либо в указанное время для будильников, либо когда пользователь взаимодействует с системным уведомлением. Будильники и уведомления могут срабатывать, когда приложение, которое их создало, больше не работает, и система использует информацию в pending intent для его запуска и выполнения действия от его имени.

Листинг 2-27 показывает, как приложение Email использует pending intent, созданный с помощью `PendingIntent.getBroadcast()`, для планирования broadcast, которые запускают синхронизацию электронной почты.

```java
private void setAlarm(long id, long millis) {
    --snip--
    Intent i = new Intent(this, MailboxAlarmReceiver.class);
    i.putExtra("mailbox", id);
    i.setData(Uri.parse("Box" + id));
    pi = PendingIntent.getBroadcast(this, 0, i, 0);
    mPendingIntents.put(id, pi);
    AlarmManager am = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
    am.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + millis, pi);
    --snip--
}
```

> [!important] 
> Pending intents могут передаваться также и не системным приложениям. Применяются те же правила: приложения, получающие экземпляр `PendingIntent`, могут выполнять указанную операцию с теми же разрешениями и идентификацией, что и создающее приложение. Поэтому следует проявлять осторожность при создании базового intent, и базовые intents должны быть как можно более конкретными (с явно указанным именем компонента), чтобы гарантировать, что intent будет получен нужными компонентами.

Реализация pending intents достаточно сложна, но она основана на тех же принципах межпроцессового взаимодействия (IPC) и изоляции (sandboxing), на которых построены другие компоненты Android.

> [!important] 
> Когда приложение создает pending intent, система извлекает его UID и PID с помощью `Binder.getCallingUid()` и `Binder.getCallingPid()`. На основе этих данных система извлекает имя пакета и идентификатор пользователя (на устройствах с несколькими пользователями) создателя и сохраняет их в `PendingIntentRecord` вместе с базовым intent и любыми дополнительными метаданными. Менеджер активности хранит список активных pending intents, сохраняя соответствующие `PendingIntentRecords`, и при срабатывании извлекает необходимую запись. Затем он использует информацию в записи, чтобы принять идентификацию создателя pending intent и выполнить указанное действие. С этого момента процесс такой же, как при запуске любого компонента Android, и выполняются те же проверки разрешений.

---
---
Предыдущая глава [[Разрешения для Content Provider]]
Раздел [[Permissions]]
Книга [[SEC Internals]]
