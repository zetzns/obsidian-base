
> [!info] 
> Как обсуждалось в предыдущем разделе, каждому процессу приложения назначаются UID, GID и дополнительные GID, когда он создается из процесса `zygote`. Ядро и системные демоны используют эти идентификаторы процессов для принятия решения о предоставлении доступа к конкретному системному ресурсу или функции.

---
## Принудительное Применение Разрешений на Уровне Ядра


> [!fact] 
> Доступ к обычным файлам, устройствам и локальным сокетам регулируется так же, как и в любой системе Linux. Одним из специфических для Android дополнений является требование, чтобы процессы, желающие создавать сетевые сокеты, принадлежали к группе `inet`. Это дополнение ядра Android известно как "параноидальная сетевая безопасность" и реализовано как дополнительная проверка в ядре Android, как показано в Листинге 2-8.

```c
#ifdef CONFIG_ANDROID_PARANOID_NETWORK
#include <linux/android_aid.h>
static inline int current_has_network(void)
{
    return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
}
#else
static inline int current_has_network(void)
{
    return 1;
}
#endif
--snip--
static int inet_create(struct net *net, struct socket *sock, int protocol, int kern)
{
    --snip--
    if (!current_has_network())
        return -EACCES;
    --snip--
}
```


> [!warning] 
> Процессы, которые не принадлежат к группе `AID_INET` (GID 3003, имя `inet`) и не имеют возможности `CAP_NET_RAW` (позволяющей использовать сокеты RAW и PACKET), получают ошибку отказа в доступе. В не-Android ядрах не определено `CONFIG_ANDROID_PARANOID_NETWORK`, и поэтому для создания сокета не требуется специальное членство в группе.

> [!warning] 
> Для того чтобы группа `inet` была назначена процессу приложения, оно должно иметь разрешение `INTERNET`. В результате, только приложения с разрешением `INTERNET` могут создавать сетевые сокеты. В дополнение к проверке учетных данных процесса при создании сокетов, ядра Android также предоставляют определенные возможности процессам, выполняемым с определенными GID: процессы, выполняемые с GID `AID_NET_RAW` (GID 3004), получают возможность `CAP_NET_RAW`, а те, которые выполняются с GID `AID_NET_ADMIN` (GID 3005), получают возможность `CAP_NET_ADMIN`.

> [!NOTE] 
> Параноидальная сетевая безопасность также используется для контроля доступа к Bluetooth-сокетам и драйверу туннелирования ядра (используется для VPN). Полный список GID Android, которые ядро обрабатывает особым образом, можно найти в файле `include/linux/android_aid.h` в дереве исходных текстов ядра.

---
## Применение Разрешений на Уровне Нативных Демонов

> [!info] 
> В то время как `Binder` является предпочтительным механизмом межпроцессного взаимодействия (IPC) в Android, низкоуровневые нативные демоны часто используют Unix-доменные сокеты (локальные сокеты) для IPC. Поскольку Unix-доменные сокеты представлены как узлы в файловой системе, стандартные разрешения файловой системы могут быть использованы для контроля доступа.

Большинство сокетов создаются с режимом доступа, который позволяет доступ только их владельцу и группе. Клиенты с другими UID и GID не могут подключиться к сокету. Локальные сокеты для системных демонов определяются в `init.rc` и создаются процессом `init` при запуске, параллельно задавая указанный режим доступа. 
Например, в Листинге 2-9 показано, как демон управления томами (vold) определен в `init.rc`:

```sh
service vold /system/bin/vold
    class core
    socket vold stream 0660 root mount
    ioprio be 2

```


> [!example] 
> Демон `vold` объявляет сокет с именем `vold` с режимом доступа `0660`, принадлежащий root и с группой, установленной на `mount`. Демон `vold` должен работать от имени root, чтобы монтировать или размонтировать тома, но члены группы `mount` (AID_MOUNT, GID 1009) могут отправлять ему команды через локальный сокет без необходимости работы от имени суперпользователя. Локальные сокеты для демонов Android создаются в директории `/dev/socket/`. Листинг 2-10 показывает, что сокет `vold` имеет владельца и разрешения, указанные в `init.rc`.

``` bash
$ ls -l /dev/socket
srw-rw---- root mount 1970-01-18 14:26 vold
```


> [!important] Передача учётных данных 
> UNIX-доменные сокеты позволяют передавать и запрашивать учётные данные клиента с использованием контрольного сообщения `SCM_CREDENTIALS` и опции пакета `SO_PEERCRED`. 
> Как и эффективные UID и GID, которые являются частью транзакции Binder, учётные данные пиров, связанные с локальным сокетом, проверяются ядром и не могут быть подделаны процессами уровня пользователя.
> Это позволяет нативным демонам реализовывать более детальный контроль над операциями, которые они позволяют для конкретного клиента, как показано в Листинге 2-11 с использованием демона `vold` в качестве примера.

```c
int CommandListener::CryptfsCmd::runCommand(SocketClient *cli, int argc, char **argv) {
    if ((cli->getUid() != 0) && (cli->getUid() != AID_SYSTEM)) {
        cli->sendMsg(ResponseCode::CommandNoPermission, "No permission to run cryptfs commands", false);
        return 0;
    }
    // --snip--
}
```

> [!example] 
> Демон `vold` позволяет команды управления зашифрованными контейнерами только клиентам, работающим от имени root (UID 0) или системных пользователей (AID_SYSTEM, UID 1000). Здесь UID, возвращаемый `SocketClient->getUid()`, инициализируется UID клиента, полученным с помощью `getsockopt(SO_PEERCRED)`, как показано в Листинге 2-12.

```c
void SocketClient::init(int socket, bool owned, bool useCmdNum) {
    struct ucred creds;
    socklen_t szCreds = sizeof(creds);
    memset(&creds, 0, szCreds);

    int err = getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &creds, &szCreds);
    if (err == 0) {
        mPid = creds.pid;
        mUid = creds.uid;
        mGid = creds.gid;
    }
}
```

> [!info] 
> Функциональность подключения к локальному сокету инкапсулирована в классе `android.net.LocalSocket` и доступна Java приложениям, позволяя высокоуровневым системным сервисам взаимодействовать с нативными демонами без использования JNI кода. Например, класс фреймворка `MountService` использует `LocalSocket` для отправки команд демону `vold`.

---

## Применение Разрешений на Уровне Фреймворка


> [!info] 
> Как и обсуждалось ранее, доступ к компонентам Android может контролироваться с помощью разрешений, путем их объявления в манифесте приложения. Система отслеживает разрешения, связанные с каждым компонентом и проверяет, были ли они предоставлены прежде, чем выдать доступ. 
> Поскольку компоненты не могут изменять требуемые ими разрешения во время выполнения, контроль со стороны системы является ***Статическим***. 
> 

> [!warning] Статический контроль
> При использовании декларативной безопасности атрибуты безопасности, такие как роли и разрешения, помещаются в метаданные компонента (файл AndroidManifest.xml в Android), а не в сам компонент, и контролируются контейнером или средой выполнения. Это имеет преимущество изоляции решений по безопасности от бизнес-логики, но может быть менее гибким, чем реализация проверок безопасности внутри компонента.

Компоненты Android также могут проверять, было ли вызывающему процессу предоставлено определенное разрешение без объявления разрешений в манифесте. Этот динамический контроль разрешений требует больше работы, но позволяет более детально контролировать доступ. ***Динамический контроль разрешений является примером императивной безопасности***, поскольку решения о безопасности принимаются каждым компонентом, а не контролируются средой выполнения.

Рассмотрим два этих подхода подробнее.

### Динамическое Применение Разрешений

> [!info] 
> Как обсуждалось в Главе 1, ядро Android реализовано как набор взаимодействующих системных сервисов, к которым можно обращаться из других процессов с использованием механизма межпроцессного взаимодействия Binder IPC. Основные сервисы регистрируются в диспетчере сервисов, и любое приложение, которое знает имя их регистрации, может получить ссылку на Binder. Поскольку у Binder нет встроенного механизма контроля доступа, когда клиенты получают ссылку, они могут вызвать любой метод базового системного сервиса, передав соответствующие параметры в `Binder.transact()`. Поэтому контроль доступа должен быть реализован каждым системным сервисом.

В Главе 1 мы показали, что системные сервисы могут регулировать доступ к экспортированным операциям, напрямую проверяя UID вызывающего процесса, полученного из `Binder.getCallingUid()`. Однако этот метод требует, чтобы сервис заранее знал список разрешенных UID, что работает только для фиксированных UID, таких как root (UID 0) и system (UID 1000). Кроме того, большинству сервисов не важно, какой именно UID у вызывающего процесса; они просто хотят проверить, было ли ему предоставлено определенное разрешение.

> [!todo] Проверка разрешений через PackageManager
> Поскольку каждый UID приложения в Android ассоциируется с уникальным пакетом (если это не часть общего идентификатора пользователя), и менеджер пакетов отслеживает разрешения, предоставленные каждому пакету, это возможно, запрашивая сервис менеджера пакетов. Проверка наличия у вызывающего процесса определенного разрешения является очень распространенной операцией, и Android предоставляет ряд вспомогательных методов в классе `android.content.Context`, которые могут выполнить эту проверку.


> [!tip] Метод Context.checkPermission
> Метод `int Context.checkPermission(String permission, int pid, int uid)` возвращает `PERMISSION_GRANTED`, если переданному UID предоставлено разрешение, и `PERMISSION_DENIED` в противном случае. Если вызывающий процесс — root или system, разрешение предоставляется автоматически. В качестве оптимизации, если запрашиваемое разрешение было объявлено вызывающим приложением, оно предоставляется без проверки фактического разрешения. Если это не так, метод проверяет, является ли целевой компонент общедоступным (экспортированным) или приватным, и отказывает в доступе ко всем приватным компонентам. Наконец, код запрашивает сервис менеджера пакетов, чтобы проверить, было ли вызывающему процессу предоставлено запрашиваемое разрешение.

```java
public int checkUidPermission(String permName, int uid) {
    synchronized (mPackages) {
        Object obj = mSettings.getUserIdLPr(uUserHandle.getAppId(uid));
        if (obj != null) {
            GrantedPermissions gp = (GrantedPermissions)obj;
            if (gp.grantedPermissions.contains(permName)) {
                return PackageManager.PERMISSION_GRANTED;
            }
        } else {
            HashSet<String> perms = mSystemPermissions.get(uid);
            if (perms != null && perms.contains(permName)) {
                return PackageManager.PERMISSION_GRANTED;
            }
        }
    }
    return PackageManager.PERMISSION_DENIED;
}
```


> [!example] 
> Здесь `PackageManagerService` сначала определяет идентификатор приложения на основе переданного UID и затем получает набор предоставленных разрешений. Если класс `GrantedPermissions` (который содержит фактический `java.util.Set<String>` с именами разрешений) содержит целевое разрешение, метод возвращает `PERMISSION_GRANTED`. Если нет, он проверяет, должно ли целевое разрешение автоматически назначаться переданному UID на основе тегов `<assign-permission>` в `platform.xml`. Если эта проверка также не удалась, метод возвращает `PERMISSION_DENIED`.

Другие вспомогательные методы проверки разрешений в классе `Context` следуют той же процедуре. Метод `int checkCallingOrSelfPermission(String permission)` вызывает `Binder.getCallingUid()` и `Binder.getCallingPid()` для получения значений, а затем вызывает `checkPermission(String permission, int pid, int uid)` с полученными значениями. Метод `enforcePermission(String permission, int pid, int uid, String message)` не возвращает результат, но вместо этого выбрасывает `SecurityException` с указанным сообщением, если разрешение не предоставлено.


> [!example] 
> Класс `BatteryStatsService` гарантирует, что только приложения, имеющие разрешение `BATTERY_STATS`, могут получить статистику батареи, вызывая `enforceCallingPermission()` перед выполнением любого другого кода.

```java
public byte[] getStatistics() {
    mContext.enforceCallingPermission(
        android.Manifest.permission.BATTERY_STATS, null);
    Parcel out = Parcel.obtain();
    mStats.writeToParcel(out, 0);
    byte[] data = out.marshall();
    out.recycle();
    return data;
}
```

### Статическое Применение Разрешений


> [!INFO] 
> Статическое применение разрешений происходит, когда приложение пытается взаимодействовать с компонентом, объявленным другим приложением. Процесс проверки учитывает разрешения, объявленные для каждого целевого компонента, и позволяет взаимодействие, если вызывающему процессу предоставлено соответствующее разрешение.
> 

> [!todo] Использование Intents для взаимодействия
> Android использует intents для описания операции, которую необходимо выполнить. Intents, которые полностью определяют целевой компонент (по имени пакета и класса), называются явными (explicit). С другой стороны, неявные intents содержат некоторые данные (часто только абстрактное действие, такое как `ACTION_SEND`), которые позволяют системе найти подходящий компонент, но они не полностью определяют целевой компонент.

Когда система получает неявный intent, она сначала разрешает его, ищет соответствующие компоненты. Если найдено более одного подходящего компонента, пользователю представляется диалог выбора. Когда целевой компонент выбран, Android проверяет, имеет ли он связанные разрешения, и если да, проверяет, были ли они предоставлены вызывающему процессу.

> [!important] Общий процесс проверки разрешений
> Общий процесс проверки аналогичен динамическому применению разрешений: UID и PID вызывающего процесса получаются с использованием `Binder.getCallingUid()` и `Binder.getCallingPid()`, UID вызывающего процесса сопоставляется с именем пакета, и связанные разрешения извлекаются. Если набор разрешений вызывающего процесса содержит те, которые требуются целевым компонентом, компонент запускается; в противном случае генерируется `SecurityException`.

> [!warning] Проверка разрешений с помощью ActivityManagerService
> Проверки разрешений выполняются `ActivityManagerService`, который разрешает указанный intent и проверяет, имеет ли целевой компонент связанный атрибут разрешения. Если да, он делегирует проверку разрешений менеджеру пакетов. Время и конкретная последовательность проверок разрешений немного отличаются в зависимости от целевого компонента.

### Контроль Разрешений для Активностей и Сервисов

> [!info] 
> В Android проверка разрешений для Activity и Service выполняется для обеспечения безопасности доступа к этим компонентам. Если целевая Activity или Service объявляют необходимые разрешения в своем манифесте, система Android проверяет, предоставлены ли эти разрешения вызывающему процессу. Если разрешения не предоставлены, генерируется исключение `SecurityException`.

> [!hint] На практике же для Activity
> Проверка разрешений для Activity выполняется, если intent, переданный в `Context.startActivity()` или `startActivityForResult()`, разрешается на activity, которое объявляет разрешение. Если вызывающий процесс не имеет необходимого разрешения, генерируется `SecurityException`.

> [!hint] На практике же для Service
> Проверка разрешений для Service выполняется, если сервис может быть запущен, остановлен или связан с использованием `Context.startService()`, `stopService()` и `bindService()`. Если целевая Service объявляет разрешение, система проверяет, предоставлено ли это разрешение вызывающему процессу.

### Применение Разрешений для Content Provider

> [!info] 
> Разрешения для Content Provider могут либо защищать весь компонент, либо конкретный экспортированный URI, и могут быть указаны разные разрешения для чтения и записи. Если указаны разные разрешения для чтения и записи, разрешение на чтение контролирует, кто может вызывать `ContentResolver.query()` для целевого провайдера или URI, а разрешение на запись контролирует, кто может вызывать `ContentResolver.insert()`, `ContentResolver.update()` и `ContentResolver.delete()` для провайдера или одного из его экспортированных URI. Проверки выполняются синхронно, когда вызывается один из этих методов.

### Применение Разрешений для Broadcast

> [!important] 
> Когда приложение отправляет широковещательное сообщение (broadcast), оно может потребовать, чтобы получатели имели определенное разрешение, используя метод `Context.sendBroadcast (Intent intent, String receiverPermission)`. Поскольку широковещательные сообщения асинхронные, проверка разрешений не выполняется при вызове этого метода. Проверка выполняется при доставке intent зарегистрированным получателям. Если целевой получатель не имеет требуемого разрешения, он пропускается и не получает широковещательное сообщение, но исключение не генерируется. В свою очередь, широковещательные приемники могут потребовать, чтобы отправители имели определенное разрешение для возможности их нацеливания.

Требуемое разрешение указывается в манифесте или при динамической регистрации широковещательного приемника. Эта проверка разрешений также выполняется при доставке широковещательного сообщения и не приводит к генерации `SecurityException`.

> [!security] 
> Таким образом, доставка широковещательного сообщения может требовать две проверки разрешений: одну для отправителя (если приемник указал разрешение) и одну для приемника (если отправитель указал разрешение).

### Защищенные и "Sticky" Широковещательные Сообщения

> [!info]
> Некоторые системные широковещательные сообщения объявлены как защищенные (например, `BOOT_COMPLETED` и `PACKAGE_INSTALLED`) и могут быть отправлены только системным процессом, выполняемым под одним из следующих UID: `SYSTEM_UID`, `PHONE_UID`, `SHELL_UID`, `BLUETOOTH_UID` или `root`. Если процесс, выполняющийся под другим UID, пытается отправить защищенное широковещательное сообщение, он получает `SecurityException` при вызове одного из методов `sendBroadcast()`


> [!warning] 
> Отправка "sticky" широковещательных сообщений (если помечены как "sticky", система сохраняет отправленный объект `Intent` после завершения широковещательной передачи) требует, чтобы отправитель имел разрешение `BROADCAST_STICKY`; в противном случае генерируется `SecurityException`, и широковещательное сообщение не отправляется.

---
---
Следующая глава [[Системные Разрешения]]
Предыдущая глава [[Назначение Разрешений]]
Раздел [[Permissions]]
Книга [[SEC Internals]]

