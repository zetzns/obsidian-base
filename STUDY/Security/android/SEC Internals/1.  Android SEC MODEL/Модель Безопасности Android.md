Как и остальная система, модель безопасности Android также использует функции безопасности, предлагаемые ядром Linux. Linux — это многопользовательская операционная система, и ядро может изолировать ресурсы пользователей друг от друга, так же как оно изолирует процессы. В системе Linux один пользователь не может получить доступ к файлам другого пользователя (если явным образом не предоставлено разрешение), и каждый процесс выполняется с идентичностью (идентификаторы пользователя и группы, обычно называемые UID и GID) пользователя, который его запустил, если только биты set-user-ID или set-group-ID (SUID и SGID) не установлены на соответствующем исполняемом файле.

---
## Особенности изоляции пользователей в Android

> [!faq] Ну не совсем
> Android тоже использует изоляцию пользователей, но делает это несколько иначе. В традиционной системе Linux UID присваивается либо другому физическому пользователю, либо службе (демону), которая выполняется в фоновом режиме.
> Android же изначально создавался для девайсов с одним единственным пользователем, отсюда UID стал определять не человека, а приложение. Какой-то уже AID (app id).

### Песочница приложений

> [!example] Application Sandbox
> Android автоматически присваивает UID приложениям при установке, выполняет их в отдельном процессе, работающем только под этим UID, а также предоставляет ему место в памяти, в котором только оно имеет права на чтение-запись.
> Таким образом, создаётся Sandbox приложений на уровне ядра, обеспечивая безопасность общего контейнера.

#### UID и GID в системе


> [!faq] Распределение UID
> В системе Android демоны и приложения работают под специально и точно распределёнными UID, очень немногие демоны и службы работают от лица root (UID 0).
> Кроме того, здесь нет привычного /etc/passwd, а системные UID определены в классическом до боли в Android - android_filesystem_config.h.
> UID для системных служб начинаются с 1000, причём 1000 - это системный пользователь (AID_SYSTEM), имеющий особые, но ограниченные при этом привилегии.
> UID для обычных приложений начинается с 10000 (AID_APP)
> А имена пользователей app_XXX или uY_aXXX (для многопользовательских Android).

![[Pasted image 20240702012535.png]]

### Управление UID приложений

> [!tip] Хранение UID
> UID приложений управляются вместе с другими метаданными пакетов в файле /data/system/packages.xml (канонический источник) и также записываются в файл /data/system/packages.list. В файле packages.list первое поле — это имя пакета, второе — UID, присвоенный приложению, третье — флаг отладки (1, если отлаживаемое), четвертое — путь к каталогу данных приложения, а пятое — метка seinfo (используемая SELinux). Последнее поле — это список дополнительных GID, с которыми приложение запускается. Каждый GID обычно связан с разрешением Android, и список GID генерируется на основе разрешений, предоставленных приложению.

### Общий UID для приложений

> [!tip] Общий UID
> Приложения могут быть установлены с использованием одного и того же UID, называемого общим идентификатором пользователя, в этом случае они могут совместно использовать файлы и даже выполняться в одном процессе. Общие UID широко используются системными приложениями, которым часто необходимо использовать одни и те же ресурсы в разных пакетах для модульности. Например, в Android 4.4 системный интерфейс и замок экрана (реализация экрана блокировки) используют UID 10012.

![[Pasted image 20240702012855.png]]
### Общие UID для сторонних приложений

> [!tip] Общий UID
> Хотя механизм общего UID не рекомендуется для несистемных приложений, он доступен и для сторонних приложений. Чтобы использовать общий UID, приложения должны быть подписаны одним и тем же ключом подписи кода. Кроме того, поскольку добавление общего UID к новой версии установленного приложения вызывает изменение его UID, система запрещает это. Следовательно, общий UID не может быть добавлен задним числом, и приложения должны быть разработаны для работы с общим UID с самого начала.

---
## Разрешения

Поскольку приложения Android изолированы в песочнице, они могут получить доступ только к своим собственным файлам и любым ресурсам устройства с доступом для всех. Такое ограниченное приложение было бы не очень интересным, поэтому Android может предоставлять дополнительные, тонко настроенные права доступа приложениям для более богатой функциональности. Эти права доступа называются разрешениями, и они могут контролировать доступ к аппаратным устройствам, подключению к Интернету, данным или службам операционной системы.

Приложения могут запрашивать разрешения, определяя их в файле AndroidManifest.xml. При установке приложения Android проверяет список запрашиваемых разрешений и решает, предоставлять их или нет. После предоставления разрешения не могут быть отозваны и доступны приложению без дополнительного подтверждения. Кроме того, для таких функций, как доступ к приватным ключам или учетным записям пользователей, требуется явное подтверждение пользователя для каждого объекта, к которому запрашивается доступ, даже если запрашивающему приложению было предоставлено соответствующее разрешение.

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <!-- Запрос разрешения на доступ к камере -->
        <uses-permission android:name="android.permission.CAMERA" />
        
        <!-- Запрос разрешения на доступ к Интернету -->
        <uses-permission android:name="android.permission.INTERNET" />

    </application>

</manifest>

```

Некоторые разрешения могут быть предоставлены только приложениям, которые являются частью операционной системы Android, либо потому что они предустановлены, либо подписаны тем же ключом, что и ОС. Сторонние приложения могут определять собственные разрешения и задавать аналогичные ограничения, известные как уровни защиты разрешений, таким образом ограничивая доступ к службам и ресурсам приложения только для приложений, созданных тем же автором.

---

## Подпись кода и платформенные ключи

> [!important]
> Все приложения Android, включая системные приложения, должны быть подписаны их разработчиком. Поскольку файлы APK Android являются расширением формата пакета Java JAR, метод подписи кода также основан на подписи JAR. Android использует подпись APK, чтобы убедиться, что обновления для приложения поступают от того же автора (это называется политикой одного источника) и для установления доверительных отношений между приложениями. Оба эти механизма безопасности реализованы путем сравнения сертификата подписи текущего установленного целевого приложения с сертификатом обновления или связанного приложения.

Системные приложения подписаны рядом платформенных ключей. Различные системные компоненты могут совместно использовать ресурсы и выполняться в одном процессе, если они подписаны одним и тем же платформенным ключом. Платформенные ключи генерируются и контролируются теми, кто поддерживает версию Android, установленную на конкретном устройстве: производители устройств, операторы связи, Google для устройств Nexus или пользователи для самосборных версий Android с открытым исходным кодом.

---
## Обновления системы

> [!faq] Update
> Устройства Android могут обновляться по воздуху (OTA) или путем подключения устройства к ПК и загрузки образа обновления с помощью стандартного клиента Android Debug Bridge (ADB) или предоставленного производителем приложения с аналогичной функциональностью. Поскольку обновление Android может требовать изменения системных файлов, прошивки модема (baseband), загрузчика (bootloader) и других частей устройства, которые недоступны напрямую из Android, процесс обновления обычно использует специальную минимальную ОС с эксклюзивным доступом ко всему оборудованию устройства. Это называется ОС восстановления или просто recovery.

---
## Verified Boot

> [!bug] Boot
> Начиная с версии 4.4, Android поддерживает проверенную загрузку с использованием цели verity10 в Device-Mapper Linux. Verity обеспечивает прозрачную проверку целостности блочных устройств с использованием криптографического хеш-дерева. Каждый узел в дереве представляет собой криптографический хеш, при этом листовые узлы содержат хеш-значение физического блока данных, а промежуточные узлы содержат хеш-значения своих дочерних узлов. Поскольку хеш в корневом узле основан на значениях всех других узлов, необходимо доверять только корневому хешу для проверки остальной части дерева.


---
---
Предыдущая глава [[Архитектура Андроида]]
Раздел [[Android Security Model]]
Книга [[SEC Internals]]
