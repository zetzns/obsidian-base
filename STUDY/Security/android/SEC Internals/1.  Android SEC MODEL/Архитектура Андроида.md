> [!info] Архитектура
> Глобально, ***android есть обычная надстройка над ядром Linux.*** Включающая в себя различные библиотеки для java, фреймворки для работы приложений, какие-то новые или модифицированные демоны, сервисы и всякое прочее.

![[Pasted image 20240629154428.png]]

Здесь же стоит отметить, например, про различие в работе систем. В исходной книге упоминается про **Андроидизмы**.

> [!tip] Андроидизм (Androidism)
> Андроидизмы - какие-либо модификации привычных UNIX концепций, появившиеся в Android.

Так вот среди прочих можно выделить эти Андроидизмы:

1. Low Memory Killer.
		Здесь стоит сказать про то, что это такое. Ну в целом, параллель ясна: OOM Killer, нооо не совсем. Дело в том, что в Android не предусмотрен Swapping, как следствие неэффективности и энергозатротности данного процесса, что очень важно в контексте мобильных устройств.
		Именно отсюда зарождаются отличия. То есть система Low Memory Killer, построенная на базе /proc в виде модуля ядра занимается очисткой процессов, которые уж больно сильно расходуют ресурсы и время. При чём, в отличие от теперь уже взятого в отдельности OOM Killer, делает он это сразу, а не при критической необходимости. 
		У LMK есть возможность настроить пороги памяти при которых будут происходить различные наказания для паразитов возможностей системы (minfree), а также возможность ориентации на приоритеты приложений (adj).
2. Anonymous Shared Memory (ashmem).
		Так как мощности мобильных устройств сильно ограничены, становятся нетерпимы для них и минусы встроенных механизмов выделения и разделения памяти в Linux. Иерархичность и постоянство памяти (отсутствие автоматической очистки) приводит к проблемам, на устранение которых нужно слишком много процессорного времени и его же ресурсов.
		Отсюда появляется ashmem, обитающий, неожиданно, в /dev/ashmem


# Native Userspace

Над уже получившимся ядром Linux, кроме прочего стоит пользовательское пространство, состоящее из INIT, нескольких нативных демонов и системных библиотек. 

> [!info] init
> init, в своей сути, аналог SystemV(SystemD), OpenRC и подобных в привычных Linux-десктопных системах. Запускается под PID=1, читает конфигурационные файлы (init.rc, init.device.rc и др.), запускает соответствующие службы и демоны и мониторит их состояние, дабы система могла работать.

# Dalvik VM

Не секрет, что Android - квинтэссенция Java'ы, однако он использует JVM (java virtual machine), предпочитая собственную архитектуры с наименованием **Dalvik**.


> [!info] Dalvik
> ***Dalvik VM*** имеет регистровую (vs Стековая у JVM) архитектуру (меньшее количество инструкций), свой формат файлов (.dex), оптимизацию кода и памяти (garbage collector), что делает его более эффективным для мобильных (малоресурсных устройств).

> [!Warning]
> Однако в последнее время (начиная с Android 4.4. Закончила переход в Android 5.0) Google начала переход с Dalvik VM на ART (Android RunTime) 

> [!info] Android Runtime
> ART внёс ключевые улучшения, позволившие оптимизировать процессы внутри устройств:
> 1. Ahead-of-Time компиляция - компиляция машинного кода из байт-кода во время установки приложения, а не его использования.
> 2. Just-in-time компиляция - компиляция машинного кода из байт-кода во время использования. 
> В Android 7.0 был установлен гибридный подход, совмещающий два типа компиляции для достижения наибольшей эффективности.
> 3. Улучшенный Garbage Collector (Mark-and-Sweep, generational garbage collector)
> 4. Поддержка многопоточности
> 

> [!List] Архитектура ART
> 1. Компиляция и выполнение кода:
> * При установки приложений DEX -> .oat (оптимизированный вариант)
> * Во время выполнения приложения ART может использовать уже готовый ранее .oat для ускорения запуска и работы приложения.
> 2. Формат файлов:
> * DEX - байт-код Java, компилируемый из исходника
> * OAT - оптимизированный вариант DEX
> * ART и ODEX - используются для хранения скомпилированного машинного кода и данных о классах

# Межпроцессорное взаимодействие (IPC)

> [!abstract]
> Как и в любой системе, подобной UNIX, в Android каждый процесс имеет своё адресное пространство и не может взаимодействовать с пространствами других процессов (изоляция). В общем случае подход верен: безопаснее, удобнее, быстрее. Однако, если процесс хочет помочь другим процессам, предоставить какие-либо услуги, например, то ему необходим механизм, благодаря которому другие процессы смогут видеть подобные предложения и взаимодействовать с ними. Такой механизм и называется ***IPC***.

Так как стандартные IPC были недостаточно оптимизированы и надёжны, для Android был разработан собственный - Binder

### Реализация Binder

Как уже было упомянуто ранее, процесс в UNIX не может получить доступ к среде другого процесса, однако в силу нашей смекалки, был создан соответствующий интерфейс IPC. В Android он представлен в /dev/binder и реализуется соответствующим модулем ядра. Абсолютно все вызовы проходят через него, так как он является центральным объектом фреймворка.

Всё взаимодействие проходит через единственный вызов ***ioctl*** со структурой ***binder_write_read***, состоящей из ***write_buffer*** (команды для драйвера) и ***read_buffer*** (команды к пользовательскому пространству).

#### Передача данных между процессами через Binder

Передача данных между процессами в Android через механизм Binder включает несколько шагов, которые обеспечивают безопасность и эффективность. Давайте рассмотрим эти шаги подробнее и другими словами.

Но как данные фактически передаются между процессами? Драйвер Binder управляет частью адресного пространства каждого процесса. Управляемый драйвером участок памяти доступен для чтения процессу, а все записи выполняются модулем ядра. Когда процесс отправляет сообщение другому процессу, ядро выделяет место в памяти целевого процесса и копирует данные сообщения непосредственно из процесса-отправителя. Затем оно ставит в очередь короткое сообщение для целевого процесса, указывающее, где находится полученное сообщение. Получатель затем может непосредственно получить доступ к этому сообщению (поскольку оно находится в его собственном адресном пространстве). Когда процесс завершает работу с сообщением, он уведомляет драйвер Binder, чтобы пометить память как свободную.

![[Pasted image 20240701133817.png]]

Рисунок 1-3 показывает упрощенную схему архитектуры IPC Binder.

> [!list] IPC
> Высокоуровневые абстракции IPC в Android, такие как:
> 1. Intents (команды с ассоциированными данными, которые доставляются компонентам через процессы),
> 2. Messengers (объекты, которые позволяют осуществлять обмен сообщениями между процессами) и
> 3. ContentProviders (компоненты, которые предоставляют интерфейс управления данными между процессами),
> -построены на основе Binder.

> [!example] AIDL 
> Кроме того, интерфейсы служб, которые необходимо предоставить другим процессам, могут быть определены с помощью языка определения интерфейсов Android (AIDL), который позволяет клиентам вызывать удаленные службы так, как если бы они были локальными объектами Java. 

Связанный инструмент aidl автоматически генерирует заглушки (представления удаленного объекта на стороне клиента) и прокси, которые сопоставляют методы интерфейса с низкоуровневым методом transact() Binder и заботятся о преобразовании параметров в формат, который может передать Binder (это называется маршалинг/демаршалинг параметров). Поскольку Binder по своей природе не имеет типов, сгенерированные AIDL-заглушки и прокси также обеспечивают безопасность типов, включая имя целевого интерфейса в каждую транзакцию Binder (в прокси) и проверяя его в заглушке.

```java
// IMyService.aidl
interface IMyService
{
	void performAction(int param);
}
```

### Безопасность Binder

На более высоком уровне все объекты, ассоциирующиеся с Binder, доступные через этот фреймворк, реализуют интерфейс IBinder, именуемый Binder-object. Вызовы к этому объекту реализуются внутри транзакций самого Binder и содержат ссылку на исходный объект, ID метода для выполнения и буфер данных. Также автоматически добавляются PID процесса и EUID (эффективный идентификатор пользователя), вызывающего процесса. Из всей этой информации вызываемый процесс может решить, нужно всё это ему или нет.

> [!Bug] Безопасно!
> При чём PID и EUID заполняются ядром, а значит подделать сущность и повысить привилегии через эту структуру нельзя.
> EUID и PID доступны через методы getCallingUid() и getCallingPid(). 

### Идентичность Binder

> [!important] Идентичность
> Одной из главных особенностей Binder является его идентичность, уникальность в своей сути. Дело в том, что если процесс A создаст объект Binder, передаст его процессу B, а тот передаст процессу C, то все вызовы всех этих процессов в отношении Binder будут обрабатываться одним и тем же объектом фреймворка. 

На деле, конечно, самим объектом будет распоряжаться на прямую только A, остальные в силе обладать лишь handle-дескриптором того же объекта.

> [!Bug] Безопасно
> Так как ядро фактически само взаимодействует с объектами Binder и поддерживает их существование, то создать копию объекта или получить ссылку на него без участия процесса IPC оказывается невозможным, поэтому и подменить его сущность нельзя.

> [!info] Способность
> Способность - есть набор прав и ссылка на целевой объект, предоставляемые в совокупности в рамках какого-либо процесса.

> [!faq] NB
> Именно на основе неподделываемости способностей программа получает права на доступ к объекту по факту обладания ей. А значит никакие списки контроля доступа не нужны.

### Токены Binder

> [!info] Токен
> В Android в качестве способности может выступать объект Binder. В таком случае он называется ***токеном***. 

Обладая токеном Binder, процесс-владелец получает полный доступ к объекту Binder, что позволяет ему выполнять транзакции на целевом объекте.
Если же действий вызывающий объект хочет реализовать больше (выбрать он их может с помощью поля code у объекта Binder), то, имея соответствующую ссылку на соответствующий объект Binder, он это сделать может без дополнительных действий.
Для более детального контроля доступа можно создать систему проверки на основе PID и EUID.
Обычно, для UID = 1000 и UID = 0 в Android разрешаются все действия, а для остальных проходят проверки.

> [!security] 
> Таким образом, в Android доступ к важным объектам Binder (системные службы и прочее) контролируется на основе двух параметров:
> - ограничение на доступ к ссылке на соответствующий объект Binder,
> - проверка идентичности вызывающего процесса перед выполнением действий на объекте Binder (реализуется при необходимости на самом Binder)

Альтернативно, объект Binder может использоваться только как способность без реализации какой-либо другой функциональности. В этом шаблоне использования один и тот же объект Binder хранится двумя (или более) взаимодействующими процессами, и процесс, действующий как сервер (обрабатывающий запросы клиентов), использует токен Binder для аутентификации своих клиентов, подобно тому, как веб-серверы используют cookie сессии.

> [!Example] 
> Один из заметных случаев использования токенов Binder, видимый в публичном API, — это оконные токены. Верхний уровень окна каждого activity ассоциирован с токеном Binder (называемым оконным токеном), который отслеживается менеджером окон Android (системной службой, ответственной за управление окнами приложений). Приложения могут получить свои собственные оконные токены, но не могут получить доступ к оконным токенам других приложений. Обычно вы не хотите, чтобы другие приложения добавляли или удаляли окна поверх ваших; каждый запрос на это должен предоставлять оконный токен, связанный с приложением, таким образом гарантируя, что запросы на окна поступают от вашего собственного приложения или от системы.

---
### Доступ к объектам Binder

Несмотря на то, что Android реализует контроль доступа к объектам Binder и единственный способ взаимодействовать с ним - получить на него прямую ссылку, некоторые объекты Binder должны быть доступны повсеместно в системе. Например, Binder-объекты системных служб, но и выдавать все ссылки разом при запуске любого приложения тоже глупо, поэтому нам нужен интерфейс, который будет делать это по мере необходимости 

> [!info] servicemanager
> servicemanager - менеджер контекста, он же - нативный демон, запускающийся на старте системы, чтобы при запуске других служб те могли записаться в его список, оставив там свой номер, имя и IBinder-object, связанный с ними.
> Естественно, что некоторые службы внутри реализуют дополнительные проверки разрешений, предоставляя свой функционал в зависимости от прав вызывающего процесса.
> В системе также стоит дополнительная защита для того, чтобы только реальные системные службы по факту могли оставлять свой Binder.
> Так, только процесс с UID = 1002 (AID_BLUETOOTH) может зарегестрировать системную службу Bluetooth


![[Pasted image 20240701215617.png]]

### Другие функции Binder

Хотя они не связаны напрямую с моделью безопасности Android, две другие заметные функции Binder - это подсчет ссылок и уведомления о смерти (также известные как link to death).

#### Подсчет ссылок

Подсчет ссылок гарантирует, что объекты Binder автоматически освобождаются, когда никто на них не ссылается. Эта функция реализована в драйвере ядра с помощью команд `BC_INCREFS`, `BC_ACQUIRE`, `BC_RELEASE` и `BC_DECREFS`. Подсчет ссылок интегрирован на различных уровнях фреймворка Android, но не виден напрямую приложениям.

#### Уведомления о смерти

Уведомления о смерти позволяют приложениям, использующим объекты Binder, размещенные в других процессах, получать уведомления, когда эти процессы завершаются ядром, и выполнять необходимую очистку. Уведомления о смерти реализованы с помощью команд `BC_REQUEST_DEATH_NOTIFICATION` и `BC_CLEAR_DEATH_NOTIFICATION` в драйвере ядра и методов `linkToDeath()` и `unlinkToDeath()` интерфейса `IBinder` во фреймворке. (Уведомления о смерти для локальных Binder не отправляются, так как локальные Binder не могут умереть без завершения хост-процесса).

```java
public class MyService extends Service {
    private final IBinder binder = new LocalBinder();

    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }

    private final IBinder.DeathRecipient deathRecipient = new IBinder.DeathRecipient() {
        @Override
        public void binderDied() {
            // Очистка и другие необходимые действия
        }
    };

    public void registerDeathNotification(IBinder remoteBinder) {
        try {
            remoteBinder.linkToDeath(deathRecipient, 0);
        } catch (RemoteException e) {
            // Обработка ошибки
        }
    }

    public void unregisterDeathNotification(IBinder remoteBinder) {
        remoteBinder.unlinkToDeath(deathRecipient, 0);
    }
}

```

---
## Библиотеки Фреймворка Android

Следующим уровнем в стеке являются библиотеки фреймворка Android, которые иногда просто называются "фреймворк". 

> [!tip] База
> Фреймворк включает все библиотеки Java, которые не являются частью стандартного времени выполнения Java (java._, javax._ и т.д.) и в основном находятся в верхнем пакете android. Фреймворк включает основные блоки для создания Android-приложений, такие как базовые классы для активностей, сервисов и контент-провайдеров (в пакетах android.app._); виджеты GUI (в пакетах android.view._ и android.widget._); и классы для доступа к файлам и базам данных (в основном в пакетах android.database._ и android.content.*). Он также включает классы, которые позволяют взаимодействовать с аппаратным обеспечением устройства, а также классы, использующие высокоуровневые службы, предлагаемые системой.

> [!info] 
> Несмотря на то, что почти вся функциональность системы Android реализована в виде системных служб, она не представлена напрямую во фреймворке, предпочитая фасадные классы, называемые менеджерами.
> Каждый менеджер напрямую связан с соответствующей службой, так BluetoothManager является фасадом для BluetoothManagerService.

```java
BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();

if (bluetoothAdapter == null) {
    // Устройство не поддерживает Bluetooth
} else {
    if (!bluetoothAdapter.isEnabled()) {
        // Включение Bluetooth
        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
    }
}
```

### Приложения

Без лишних слов, на вершине стэка Android находятся пользовательские приложения, с которыми мы взаимодействуем напрямую.

### Системные приложения

> [!info] 
> Системные приложения включены в образ Android и доступны только для чтения (располагаются в /system), а значит не могут быть удалены или изменены пользователем. Потому такие приложения считаются безопасными и имеют намного больше привилегий, чем другие приложения.  

Хотя системные приложения не могут быть удалены или изменены, они могут быть обновлены пользователями, если обновления подписаны тем же приватным ключом, и некоторые из них могут быть заменены пользовательскими приложениями. Например, пользователь может выбрать замену предустановленного приложения запуска или метода ввода на стороннее приложение.

### Пользовательские приложения

> [!info]
> Приложения, установленные пользователями, устанавливаются на специально выделенный раздел с правами на запись (обычно монтируется как /data), который хранит пользовательские данные и может быть удален по желанию. Каждое приложение работает в выделенной безопасности "песочнице" и обычно не может влиять на другие приложения или получать доступ к их данным. Кроме того, приложения могут получать доступ только к тем ресурсам, для использования которых им было явно предоставлено разрешение.

Разделение привилегий и принцип минимальных привилегий являются центральными элементами модели безопасности Android, и мы рассмотрим, как они реализованы, в следующем разделе.

### Компоненты приложений Android

Приложения Android состоят из слабо связанных компонентов и, в отличие от традиционных приложений, могут иметь более одной точки входа. Каждый компонент может предлагать несколько точек входа, к которым можно обратиться на основе действий пользователя в том же или другом приложении, или быть вызванным системным событием, на которое приложение зарегистрировалось для получения уведомления.

Компоненты и их точки входа, а также дополнительные метаданные, определены в манифестном файле приложения, который называется `AndroidManifest.xml`. Как и большинство файлов ресурсов Android, этот файл компилируется в бинарный XML-формат (похожий на ASN.1) перед включением в пакет приложения (APK), чтобы уменьшить размер и ускорить разбор. Самое важное свойство приложения, определенное в манифестном файле, — это имя пакета приложения, которое уникально идентифицирует каждое приложение в системе. Имя пакета имеет такой же формат, как и имена пакетов Java (обратная нотация доменного имени; например, `com.google.email`).

Файл `AndroidManifest.xml` анализируется при установке приложения, и пакеты и компоненты, которые он определяет, регистрируются в системе. Android требует, чтобы каждое приложение было подписано с использованием ключа, контролируемого его разработчиком. Это гарантирует, что установленное приложение не может быть заменено другим приложением, заявляющим, что у него то же имя пакета (если только оно не подписано тем же ключом, в таком случае существующее приложение обновляется).

> [!list] Основные компоненты приложений Android перечислены ниже.

> [!list] Активности (Activities)
> Активность — это один экран с пользовательским интерфейсом. Активности являются основными строительными блоками GUI приложений Android. Приложение может иметь несколько активностей, и хотя они обычно разрабатываются для отображения в определенном порядке, каждая активность может быть запущена независимо, возможно, другим приложением (если это разрешено).

> [!list] Сервисы (Services)
> Сервис — это компонент, который работает в фоновом режиме и не имеет пользовательского интерфейса. Сервисы обычно используются для выполнения долгосрочных операций, таких как загрузка файла или воспроизведение музыки, без блокировки пользовательского интерфейса. Сервисы также могут определять удаленный интерфейс с использованием AIDL и предоставлять некоторые функции другим приложениям. Однако, в отличие от системных служб, которые являются частью ОС и всегда работают, сервисы приложений запускаются и останавливаются по мере необходимости.

> [!list] Контент-провайдеры (Content Providers)
> Контент-провайдеры предоставляют интерфейс к данным приложения, которые обычно хранятся в базе данных или файлах. Контент-провайдеры могут быть доступны через IPC и в основном используются для совместного использования данных приложения с другими приложениями. Контент-провайдеры предлагают тонкий контроль над тем, какие части данных доступны, позволяя приложению делиться только подмножеством своих данных.

> [!list] Приемники широковещательных сообщений (Broadcast Receivers)
> Приемник широковещательных сообщений — это компонент, который реагирует на системные события, называемые широковещательными сообщениями. Широковещательные сообщения могут исходить от системы (например, объявление об изменениях в сетевом подключении) или от пользовательского приложения (например, объявление о завершении обновления данных в фоновом режиме).

---
---
Следующая глава  [[Модель Безопасности Android]]
Раздел [[Android Security Model]]
Книга [[SEC Internals]]
