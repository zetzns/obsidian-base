
> [!info] 
> Здесь мы опишем структуру и содержание `.dex` файлов, которые используются для хранения набора определений классов и связанных с ним данных.

| Название  |                   Описание                    |
| :-------: | :-------------------------------------------: |
|   byte    |               8-byte signed int               |
|   ubyte   |              8-byte unsigned int              |
|   short   |    16-bit signed int, ***little-endian***     |
|  ushort   |                   unsigned                    |
|    int    |    32-bit signed int, ***little-endian***     |
|   uint    |                   unsigned                    |
|   long    |    64-bit signed int, ***little-endian***     |
|   ulong   |                   unsigned                    |
|  sleb128  |     signed LEB128, ***variable-length***      |
|  uleb128  |                   unsigned                    |
| uleb128p1 | unsigned LEB128 plus 1, ***variable-length*** |

---
## LEB128

> [!info] 
> `LEB128` (Little-Endian Base 128) - кодировка произвольной длины или беззнаковых целых величин. В файле `.dex` **LEB128** используется только для кодирования 32-битных величин.

> [!important] 
> Каждое закодированное значение `LEB128` состоит из одного-пяти байтов, которые вместе представляют собой одно 32-битное значение. Для каждого байта установлен старший бит, за исключением последнего байта в последовательности, для которой самый старший бит свободен. Оставшиеся семь бит каждого байта являются полезной нагрузкой, ***причём младшие биты 7 битов находятся в первом байте, следующие - во втором и так далее.***

> [!warning] 
> В случае `sleb128` (signed) наиболее значимый бит полезной нагрузки последнего байта в последовательности расширяется знаком для получения конечного результата. В беззнаковом случае (`uleb128`) любые биты, не представленные явно, интерпретируются как 0.

##### **Побитовая диаграмма двухбайтового значения LEB128**
| Первый байт |      |      |      |      |      |      |      | Второй байт |       |
| :---------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----------- | ----- |
|      1      | бит6 | бит5 | бит4 | бит3 | бит2 | бит1 | бит0 | 0           | бит13 |


> [!new] 
> Вариант `uleb128p1` используется для представления знакового значения, где представление числа равно значению плюс один, закодированное в формате `uleb128`. Это делает кодирование числа `-1` (которое также можно рассматривать как беззнаковое значение `0xffffffff`) — но никакое другое отрицательное число — однобайтовым. Этот метод полезен в тех случаях, когда представленное число должно быть либо неотрицательным, либо `-1` (или `0xffffffff`), и когда другие отрицательные значения не допускаются (или в тех случаях, когда использование больших беззнаковых значений маловероятно).

| Encoded Sequence | As `sleb128` | As `uleb128` | As `uleb128p1` |
| ---------------- | ------------ | ------------ | -------------- |
| 00               | 0            | 0            | -1             |
| 01               | 1            | 1            | 0              |
| 7f               | -1           | 127          | 126            |
| 80 7f            | -128         | 16256        | 16255          |

---
# Макет файла

| Имя            | Формат               | Описание                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Header         | header_item          | Заголовок                                                                                                                                                                                                                                                                                                                                                                                                                   |
| string_ids     | string_id_item[]     | Список строковых идентификаторов. Это идентификаторы для всех строк, используемых этим файлом, либо для внутреннего именования (например, дескрипторов типов), либо в качестве константных объектов, на которые ссылается код. Этот список должен быть отсортирован по содержимому строк с использованием значений кодовых точек UTF-16 (не с учетом локали), и он не должен содержать повторяющихся записей.               |
| type_ids       | type_id_item[]       | type identifiers list. Это идентификаторы для всех типов (классов, массивов или примитивных типов), на которые ссылается этот файл, независимо от того, определены они в файле или нет. Этот список должен быть отсортирован по индексу `string_id`, и он не должен содержать повторяющихся записей.                                                                                                                        |
| proto_ids      | proto_id_item[]      | Это идентификаторы для всех прототипов, на которые ссылается этот файл. Этот список должен быть отсортирован по типу возвращаемого значения (по индексу `type_id`), а затем по списку аргументов (лексикографический порядок, отдельные аргументы упорядочены по `type_id`). Список не должен содержать повторяющихся записей.                                                                                              |
| field_ids      | field_id_item[]      | список идентификаторов полей. Это идентификаторы для всех полей, на которые ссылается этот файл, независимо от того, определены они в файле или нет. Этот список должен быть отсортирован, где определяющий тип (по `type_id`) является старшим порядком, имя поля (по `string_id`) является промежуточным порядком, а тип (по `type_id`) является младшим порядком. Список не должен содержать повторяющихся записей.      |
| method_ids     | method_id_item[]     | Список идентификаторов методов. Это идентификаторы для всех методов, на которые ссылается этот файл, независимо от того, определены они в файле или нет. Этот список должен быть отсортирован, где определяющий тип (по `type_id`) является старшим порядком, имя метода (по `string_id`) - промежуточным порядком, а прототип метода (по `proto_id`) - младшим порядком. Список не должен содержать повторяющихся записей. |
| class_defs     | class_def_item[]     | Список определений классов. Классы должны быть упорядочены таким образом, чтобы суперкласс данного класса и реализованные интерфейсы появлялись в списке раньше, чем ссылающийся класс. Кроме того, недопустимо, чтобы определение для одноименного класса появлялось в списке более одного раза.                                                                                                                           |
| call_site_ids  | call_site_id_item[]  | Список идентификаторов сайтов вызовов. Это идентификаторы для всех сайтов вызовов, на которые ссылается этот файл, независимо от того, определены они в файле или нет. Этот список должен быть отсортирован в порядке возрастания `call_site_off`.                                                                                                                                                                          |
| method_handles | method_handle_item[] | Список дескрипторов метода. Список всех дескрипторов методов, на которые ссылается этот файл, независимо от того, определены они в файле или нет. Этот список не сортируется и может содержать дубликаты, которые будут логически соответствовать разным экземплярам дескрипторов методов.                                                                                                                                  |
| data           | ubyte[]              | Область данных, содержащая все вспомогательные данные для перечисленных выше таблиц. Разные элементы имеют разные требования к выравниванию, и перед каждым элементом вставляются байты заполнения, если это необходимо для достижения правильного выравнивания.                                                                                                                                                            |
| link_data      | ubyte[]              | Данные используются в статически скомпонованных файлах. Формат данных в этом разделе в данном документе не указан. Этот раздел пуст в несвязанных файлах, и реализации времени выполнения могут использовать его по своему усмотрению.                                                                                                                                                                                      |

---
# Определения битовых полей, строк и констант

> [!new] 
> Константный массив/строка `DEX_FILE_MAGIC` — это список байтов, которые должны отображаться в начале `.dex`, чтобы он был распознан как таковой. Значение намеренно содержит новую строку (`"\n"` или `0x0a`) и нулевой байт ("`"\0"` или `0x00`), чтобы помочь в обнаружении определенных форм повреждения. Значение также кодирует номер версии формата в виде трех десятичных цифр, которые, как ожидается, будут монотонно увеличиваться с течением времени по мере развития формата.

```java
ubyte[8] DEX_FILE_MAGIC = { 0x64 0x65 0x78 0x0a 0x30 0x33 0x39 0x00 }
                        = "dex\n039\0"
```

#### ENDIAN_CONSTANT и REVERSE_ENDIAN_CONSTANT

> [!important] 
> Константа **ENDIAN_CONSTANT** используется для указания порядка байтов (эндиянности) файла, в котором она находится. Хотя стандартный формат .dex является little-endian (младший байт идет первым), реализации могут выбрать выполнение байт-свапа (перестановки байтов). Если при этом реализация сталкивается с заголовком, у которого поле **endian_tag** имеет значение **REVERSE_ENDIAN_CONSTANT** вместо **ENDIAN_CONSTANT**, это будет означать, что файл был байт-свапнут из ожидаемой формы.

```java
uint ENDIAN_CONSTANT = 0x12345678;
uint REVERSE_ENDIAN_CONSTANT = 0x78563412;
```

#### NO_УКАЗАТЕЛЬ
##### Embedded in class_def_item and debug_info_item

> [!info] 
> Константа `NO_INDEX` используется для указания на отсутствие значения индекса.

**Заметка:** Это значение не определено равным `0`, потому что на самом деле это обычно допустимый индекс.

Выбранное значение `NO_INDEX` можно представить в виде одного байта в кодировке `uleb128p1`.

```java
uint NO_INDEX = 0xffffffff;    // == -1 if treated as a signed int
```

#### Определения access_флагов
##### Внедрено в class_def_item, encoded_field, encoded_method и InnerClass

Битовые поля этих флагов используются для обозначения доступности и общих свойств классов и членов класса.

| Имя                 | Ценность  | Для классов (и аннотаций `InnerClass`)                 | Для полей                                                                    | Для методов                                                                                    |
| ------------------- | --------- | ------------------------------------------------------ | ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| `ACC_PUBLIC`        | `0x1`     | `public`: виден везде                                  | `public`: виден везде                                                        | `public`: виден везде                                                                          |
| `ACC_PRIVATE`       | `0x2`     | * `private`: виден только определяющему классу         | `private`: виден только определяющему классу                                 | `private`: виден только определяющему классу                                                   |
| `ACC_PROTECTED`     | `0x4`     | * `protected`: видимость для пакета и подклассов       | `protected`: видимость для пакета и подклассов                               | `protected`: видимость для пакета и подклассов                                                 |
| `ACC_STATIC`        | `0x8`     | * `static`: не строится с внешней ссылкой `this`       | `static`: глобальный для определения класса                                  | `static`: не принимает `this`                                                                  |
| `ACC_FINAL`         | `0x10`    | `final`: не подклассифицируется                        | `final`: неизменяемый после постройки                                        | `final`: не может быть переопределен                                                           |
| `ACC_SYNCHRONIZED`  | `0x20`    |                                                        |                                                                              | `synchronized`: Связанная блокировка автоматически устанавливается вокруг вызова этого метода. |
| `ACC_VOLATILE`      | `0x40`    |                                                        | `volatile`: специальные правила доступа для обеспечения безопасности потоков |                                                                                                |
| `ACC_BRIDGE`        | `0x40`    |                                                        |                                                                              | bridge, автоматически добавляемый компилятором в качестве типо-безопасного моста               |
| `ACC_TRANSIENT`     | `0x80`    |                                                        | `transient`: не должен сохраняться при сериализации по умолчанию             |                                                                                                |
| `ACC_VARARGS`       | `0x80`    |                                                        |                                                                              | Последний аргумент должен рассматриваться компилятором как аргумент "rest"                     |
| `ACC_NATIVE`        | `0x100`   |                                                        |                                                                              | `native`: реализован в нативном коде                                                           |
| `ACC_INTERFACE`     | `0x200`   | `interface`: многократно реализуемый абстрактный класс |                                                                              |                                                                                                |
| `ACC_ABSTRACT`      | `0x400`   | `abstract`: Не может быть создано напрямую             |                                                                              | `abstract`: Не реализовано этим классом                                                        |
| `ACC_STRICT`        | `0x800`   |                                                        |                                                                              | `strictfp` строгие правила для арифметики с плавающей запятой                                  |
| `ACC_SYNTHETIC`     | `0x1000`  | Не определено напрямую в исходном коде                 | Не определено напрямую в исходном коде                                       | Не определено напрямую в исходном коде                                                         |
| `ACC_ANNOTATION`    | `0x2000`  | объявлен как класс аннотаций                           |                                                                              |                                                                                                |
| `ACC_ENUM`          | `0x4000`  | объявлен как перечисляемый тип                         | объявлено как перечисляемое значение                                         |                                                                                                |
| _(не используется)_ | `0x8000`  |                                                        |                                                                              |                                                                                                |
| `ACC_CONSTRUCTOR`   | `0x10000` |                                                        |                                                                              | метод конструктора (инициализатор класса или экземпляра)                                       |


> [!NOTE] 
> * Разрешено включать только для аннотаций `InnerClass` и никогда не должно быть включено в `class_def_item`.

#### Модифицированная кодировка UTF-8

В качестве уступки для упрощения поддержки устаревших версий, формат `.dex` кодирует свои строковые данные в де-факто стандартную модифицированную форму UTF-8, далее именуемую MUTF-8. Эта форма идентична стандартной UTF-8, за исключением:

- Используются только одно-, двух- и трехбайтовые кодировки.
- Кодовые точки в диапазоне `U+10000` ... `U+10ffff` закодированы как суррогатная пара, каждая из которых представлена в виде трехбайтового закодированного значения.
- Кодовая точка `U+0000` закодирована в двухбайтовой форме.
- Простой нулевой байт (значение `0`) указывает на конец строки, как и стандартная интерпретация языка C.

### Коды типов

| Тип элемента               | Constant                        | Ценность | Размер элемента в байтах                  |
| -------------------------- | ------------------------------- | -------- | ----------------------------------------- |
| header_item                | TYPE_HEADER_ITEM                | `0x0000` | `0x70`                                    |
| string_id_item             | TYPE_STRING_ID_ITEM             | `0x0001` | `0x04`                                    |
| type_id_item               | TYPE_TYPE_ID_ITEM               | `0x0002` | `0x04`                                    |
| proto_id_item              | TYPE_PROTO_ID_ITEM              | `0x0003` | `0x0c`                                    |
| field_id_item              | TYPE_FIELD_ID_ITEM              | `0x0004` | `0x08`                                    |
| method_id_item             | TYPE_METHOD_ID_ITEM             | `0x0005` | `0x08`                                    |
| class_def_item             | TYPE_CLASS_DEF_ITEM             | `0x0006` | `0x20`                                    |
| call_site_id_item          | TYPE_CALL_SITE_ID_ITEM          | `0x0007` | `0x04`                                    |
| method_handle_item         | TYPE_METHOD_HANDLE_ITEM         | `0x0008` | `0x08`                                    |
| map_list                   | TYPE_MAP_LIST                   | `0x1000` | `4 + (размер.товара * 12)`                |
| type_list                  | TYPE_TYPE_LIST                  | `0x1001` | `4 + (размер.товара * 2)`                 |
| annotation_set_ref_list    | TYPE_ANNOTATION_SET_REF_LIST    | `0x1002` | `4 + (размер.товара * 4)`                 |
| annotation_set_item        | TYPE_ANNOTATION_SET_ITEM        | `0x1003` | `4 + (размер.товара * 4)`                 |
| class_data_item            | TYPE_CLASS_DATA_ITEM            | `0x2000` | `_подразумеваемый; необходимо разобрать_` |
| code_item                  | TYPE_CODE_ITEM                  | `0x2001` | `_подразумеваемый; необходимо разобрать_` |
| string_data_item           | TYPE_STRING_DATA_ITEM           | `0x2002` | `_подразумеваемый; необходимо разобрать_` |
| debug_info_item            | TYPE_DEBUG_INFO_ITEM            | `0x2003` | `_подразумеваемый; необходимо разобрать_` |
| annotation_item            | TYPE_ANNOTATION_ITEM            | `0x2004` | `_подразумеваемый; необходимо разобрать_` |
| encoded_array_item         | TYPE_ENCODED_ARRAY_ITEM         | `0x2005` | `_подразумеваемый; необходимо разобрать_` |
| annotations_directory_item | TYPE_ANNOTATIONS_DIRECTORY_ITEM | `0x2006` | `_подразумеваемый; необходимо разобрать_` |
| hiddenapi_class_data_item  | TYPE_HIDDENAPI_CLASS_DATA_ITEM  | `0xF000` | `_подразумеваемый; необходимо разобрать_` |
