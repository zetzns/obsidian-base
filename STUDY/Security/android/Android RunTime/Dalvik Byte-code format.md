> [!info]
> Здесь мы рассмотрим детально общий дизайн байт-кода Dalvik.

> [!fact] 
> В целом вся система построена для приблизительной имитации соглашений о вызовах в стиле C и устройства реальный встроенных архитектур.
> 

1. Машина основано на `регистрах`, а размер [[Stack Frame]] фиксируется при создании.
2. При использование битовых значений (`int` и `double` например) регистры считаются 32 битами в ширину. Соседние пары регистров используются для 64-разрядных значений. Для пар регистров не требуется выравнивание.
3. При использование ссылок на объекты, регистры считаются достаточно широкими, чтобы вмещалась ровно одна ссылка.
4. `Object (NULL) == (int) 0`
5. _N_ аргументов метода попадают в последние _N_ регистров кадра вызова метода, по порядку. Широкие аргументы используют два регистра. Методам экземпляра передается ссылка `this` в качестве первого аргумента.

> [!important]
> Единицей хранения в потоке инструкций является 16-разрядная беззнаковая величина. Некоторые биты в некоторых инструкциях игнорируются / должны быть равны нулю.

Инструкции не ограничиваются определенным типом. Например, инструкции, которые перемещают значения 32-разрядных регистров без интерпретации, не должны указывать, перемещаются ли они целыми числами или числами с плавающей точкой.

> [!info] 
> Существуют отдельно перечисляемые и индексируемые [[Constant pools]] для ссылок на строки, типы, поля и методы.

Поскольку на практике редко для метода требуется более 16 регистров, а также поскольку потребность в более чем восьми регистрах является достаточно распространенным _явлением_, многие инструкции ограничиваются адресацией только к первым 16 регистрам. Когда это разумно возможно, инструкции разрешают ссылки до первых 256 регистров. Кроме того, некоторые инструкции имеют варианты, которые позволяют использовать гораздо большее количество регистров, включая пару универсальных инструкций `move`, которые могут обращаться к регистрам в диапазоне `v0` до `v65535`. В случаях, когда вариант инструкции недоступен для обращения к нужному регистру, ожидается, что содержимое регистра будет перемещено из исходного регистра в нижний регистр (до операции) и/или перемещено из регистра с низким результатом в высокий регистр (после операции).

---
## Human Syntax and mnemonics


> [!important] 
> Dest-then-source.

Некоторые опкоды имеют суффикс для устранения неоднозначности, указывающий на тип(ы), с которыми они работают:
- 32-разрядные коды операций общего типа не помечены.
-  Общие 64-битные коды операций имеют суффикс `-wide`.
-  Коды операций, специфичные для типа, имеют суффикс их типа (или прямую аббревиатуру), один из: `-boolean` `-byte` `-char` `-short` `-int` `-long` `-float` `-double` `-object` `-string` `-class` `-void`.

Некоторые опкоды имеют суффикс для устранения неоднозначности, чтобы различать идентичные операции, которые имеют разные макеты инструкций или опции. Эти суффиксы отделены от основных имен косой чертой («`/`») и в основном существуют для того, чтобы обеспечить взаимно однозначное отображение со статическими константами в коде, который генерирует и интерпретирует исполняемые файлы (то есть для уменьшения двусмысленности для людей).

Например, в инструкции "`move-wide/from16 vAA, vBBBB`":
- "`move`" - это базовый код операции, указывающий на базовую операцию (перемещение значения регистра).
- "`wide`" — это суффикс названия, указывающий на то, что он работает с широкими (64-битными) данными.
- "`from16`" — это суффикс опкода, указывающий на вариант, который имеет ссылку на 16-битный регистр в качестве источника.
-  "`vAA` - это регистр назначения (подразумеваемый операцией; опять же, правило заключается в том, что аргументы назначения всегда идут первыми), который должен находиться в диапазоне `v0` - `v255`.
-  "`vBBBB`" – это регистр источника, который должен находиться в диапазоне `v0` – `v65535`.

---
