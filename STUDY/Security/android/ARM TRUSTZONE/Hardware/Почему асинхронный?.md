
> [!important] 
> Начнем с того, что ARMv7A — архитектура с конвейером команд, где инструкции заранее разбиваются процессором и выполняются не строго последовательно. Исполнение части инструкций может происходить параллельно с другими. 

```c
STR r1, [r2]	// *r2 = r1;
ADD r2, r2, #16 // r2 = r2 + 16;
```

Здесь первая команда сохраняет r1 по адресу r2, а вторая увеличивает r2. После исполнения первой команды, в общем случае, сохранение в память _только начнется_, и возможно, еще не закончится, когда будет выполнена полностью вторая инструкция.  
  
Далее, у процессора есть cache, в котором записанная ячейка застрянет на неопределенное количество времени, и ошибка доступа потенциально произойдет только в момент синхронизации кеша с памятью.

> [!fact] 
> Потом, даже если область памяти не кешируется: память в ARM делится на Normal, Strongly Ordered и Device Memory, допуская разные вольности со стороны процессора по изменению порядка реальных обращений к памяти и устройствам через AXI. В результате, транзакция через AXI может произойти не сразу из-за того, что доступ к устройству занят другим обращением.

> [!finally] 
> Ну и наконец, если доступ к обычному Bus Slave вызвал Abort, то это будет внешний по отношению к процессорному ядру логический сигнал. Ядро никак не ожидает, что этот сигнал синхронизирован с тем, что происходит сейчас в конвейере команд, и это абсолютно справедливо: ядро даже не может на 100% определить причину такого аборта.

> [!danger]
> При любом из этих обстоятельств ARM сгенерирует Asynchronous Abort, сообщая нам, что _попытка запрещенного доступа была, но, сколько тактов или инструкций назад — он не знает
