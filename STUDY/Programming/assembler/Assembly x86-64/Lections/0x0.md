# Компиляция

> [!important] 
> `file.c` с помощью **препроцессора** и подключаемых `хэдеров` формирует файл для Компилятора (Преобразует язык), дальше Компилятор преобразует язык высокого уровня в Асм, Ассемблер переводит `Асм код` в `объектный файл`, который компоновщиком (линковщик) формируется в `итоговый файл`.

> [!fact] 
> Линковщик подключает все нужные библиотеки (libc в т.ч.) и создаёт `динамическое` или `статическое` подключение к таковым для файла.

# Разные платформы

> [!attention] 
> Один и тот же бинарник `декомпилированный` на разных архитектурах **даже внутри платформы x86-64*** будут выглядеть по-разному

# Hello World!

```asm
section .data
	msg db "Hello World!", 10

section .text
	mov rsi, msg
	mov rax, 1
	mov rdi, 1
	mov rdx, 13
	syscall

	mov rax, 60
	mov rdi, 0
	syscall
```

```shell
nasm -f elf64 hello.s -o hello.o
ld hello.o -o hello
```

# Зачем нужны макросы в C

> [!important] 
> Все значения, определённые в макросах вычисляются на фазе `препроцессора`, что упрощает работу `компилятора`.

# Язык C в Asm

> [!hint] 
> С помощью `gcc -s file.c` превращает наш файл 
> 

> [!hint] 
> Флаг `-m32` превращает `source-file` в ассемблерный код `32-битной платформы`.

> [!hint] 
> Флаг `-masm=intel` меняет специфику кода на `Intel`.

# Объектный файл

> [!important] 
> `Объектный файл не является исполняемым`. Объектный файл является файлом типа `shared object` (ELF - linux, PE - Win, maco - OSX).

# Little-endian

> [!check] 
> Чтобы упростить работу процессору, иногда используется обратный порядок байтов, он же `little-endian`.

# Assembler Out

> [!fact] 
> `a.out` - Assembler OUT файл.

# stripped

> [!check] 
> `stripped` флаг файла указывает на наличие базовой обфусцикации.

# Интерпретатор

> [!important] 
> Исполнение програмы начинается с выделения ***адресного пространства*** (`куча`, `стэк`, `дата`, `наш код`), передача управления `интерпретатору`, которйы подгружает все нужные библиотеки и прочее.

# Objdump

> [!key] 
> Исследование объектного фала с помощью `objdump -M intel a.out` может помочь выявить интерпретатор даже на этом уровне, а также в целом получить ассемблерный код всего файла. 

# Op-code

> [!important] 
> Байты слева в дампе - `смещение` и `оп-код инструкций` - команда на языке байтов, представление нашей мнемоники для компьютера.


